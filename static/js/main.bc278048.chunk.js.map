{"version":3,"sources":["VIBAH/OurGeometryLibrary.js","VIBAH/glsl-utilities.js","VIBAH/OurMatrix.js","VIBAH/OurWebGL.js","VIBAH/OurUtilities.js","VIBAH/OurTransformations.js","VIBAH/Our3DObject.js","VIBAH/OurCachedMeshes.js","VIBAH/OurUniverse.js","VIBAH/OurAnimations.js","objects/sphinx.js","objects/camel.js","objects/Detroit.js","objects/vineyard.js","scenes/OurScene.js","objects/mummy.js","objects/shepherd.js","objects/UFO.js","scenes/OurSandbox.js","App.js","reportWebVitals.js","index.js"],"names":["icosahedron","X","Z","type","params","vertices","facesByIndex","Cone","radius","height","radialSegments","heightSegments","deltaRotation","Math","PI","deltaHeight","deltaRadius","push","i","j","sin","cos","length","Cylinder","closed","vertexOffset","Extrude","vertices2D","faces2D","depth","splice","half","Lathe","points","segments","phiStart","phiLength","rotationPerSegment","forEach","givenPoint","RegularPolygon","numberOfSides","numberOfPoints","increment","Sphere","currentRadius","sqrt","Torus","innerRadius","tubeRadius","tubularSegments","arc","u","v","Tube","outerRadius","cylinderVertices","initVertexBuffer","gl","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","compileShader","shaderSource","shaderType","compileError","shader","createShader","getShaderParameter","COMPILE_STATUS","MatrixLibrary","identityMatrix","Matrix","scaleMatrix","width","translationMatrix","x","y","z","rotationMatrix","xRotationMatrix","yRotationMatrix","zRotationMatrix","multiply","orthographicProjectionMatrix","top","bottom","right","left","near","far","perspectiveMatrix","rotateAboutPoint","point","rotation","map","element","initialValue","elements","rows","columns","getRows","getColumns","scalarMultiply","scalar","row","col","otherMatrix","Array","isArray","Error","rowProduct","apply","Number","prototype","valueOf","result","slice","aRow","bRow","toArray","resultArray","column","useInitWebGL","universe","canvasRef","useRef","useState","animationWrapper","setanimationWrapper","useEffect","canvas","current","getContext","getGL","enable","DEPTH_TEST","clearColor","viewport","abort","shaderProgram","vertexShaderSource","fragmentShaderSource","linkError","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","linkShaderProgram","getProgramParameter","LINK_STATUS","initSimpleShaderProgram","alert","getShaderInfoLog","useProgram","vertexPosition","getAttribLocation","enableVertexAttribArray","vertexColor","normals","matrix","getUniformLocation","projectionMatrix","cameraMatrix","lightDirection","lightColor","ambientLight","drawObject","object","change","verticesBuffer","normalsBuffer","colorsBuffer","colors","transform","uniformMatrix4fv","FALSE","vertexAttribPointer","FLOAT","drawArrays","mesh","isWireframe","LINES","TRIANGLES","drawScene","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","scene","camera","uniform3fv","light","direction","color","objectsToDraw","flush","previousTimestamp","advanceScene","timestamp","window","requestAnimationFrame","progress","tick","startAnimation","ReactWebGL","props","ref","onClick","event","click","checkDimensions","v1","v2","dimensions","Vector","this","call","arguments","max","s","dot","divide","magnitude","unitv","unit","toRawTriangleArray","protoGeometry","face","vertexIndex","toRawLineArray","maxI","Transform","TransformableObject","translate","Translate","rotate","Rotate","scale","Scale","RotateAboutPoint","OurMesh","wireframe","faceted","isFaceted","cachedVertices","cachedNormals","cachedFacetedWireframeNormals","cachedSmoothWireframeNormals","cachedFacetedFacesNormals","cachedSmoothFacesNormals","cachedWireframeVertices","cachedNotWireframeVertices","facesChanged","updateCachedVertices","newCachedVertices","newIsWireframe","updateCachedNormals","setWireframe","newFaceted","setIsFaceted","newVal","toggleIsFaceted","facetedNormals","smoothNormals","normalsByFace","n","rawVertices","cross","normalsByRawVertex","fill","add","normalsByVertex","Our3DObject","cachedColors","colorArray","name","newColorArray","calcColors","faceIndex","maxi","concat","setColors","setRandomColors","byVertex","random","toggleFaceted","newValue","toggleWireframe","transformMatrix","transformVertices","vertex","Our3DGroup","objects","group","filter","flatMap","flatGroup","remove","groupObject","nestedGroup","getObjectByName","searchName","find","undefined","OurLight","OurAmbientLight","newColor","OurCamera","center","projectionOptions","projectionType","newMatrix","scaleFactor","cachedMesh","Geometries","geometry","xFactor","yFactor","zFactor","factor","cachedMeshes","searchForCachedMesh","console","log","OurCachedObject","OurObject","Scene","cast","castMember","animations","CachedObjects","addAnimation","newAnimation","timeElapsed","anim","BigBang","setUniverse","addToUniverse","removeFromUniverse","MatrixAnimation","objectToAffect","animationMatrix","affectMatrix","SphinxFactory","body","EyeFactory","socket","sclera","iris","eye","mouth","lefteye","righteye","eyes","head","ToeFactory","toe1","toe2","toe3","leftToes","rightToes","toes","leg1","leg2","legs","Sphinx","CamelFactory","fidelity","neck","legMesh","legFL","legFR","legBL","legBR","humpMesh","hump1","hump2","humps","Camel","shape","rgb","StarFactory","star","star2","stars","PyramidFactory","position","pyramid","Vineyard","GrapeFactory","grapeColor","stem","toprow_grape1","toprow_grape2","toprow_grape3","toprow_grape4","secondrow_grape1","secondrow_grape2","secondrow_grape3","thirdrow_grape1","thirdrow_grape2","final_grape","first_grape_in_bunch","second_grape_in_bunch","third_grape_in_bunch","Bunch","first_grape_position","second_grape_position","third_grape_position","first_grape_tracking_position","second_grape_tracking_position","third_grape_tracking_position","ExampleUniverse","pyramid2","pyramid3","movingUp","displacement","isActive","ground","sky","sphinx","movingLeft","mummy","mummyColor","upperBody","lowerBody","feet","sarcophagus","Mummy","MummyFactory","camel1","camel2","camelHerd","shepherd","leftLeg","rightLeg","shirt","arm","staff","staffBase","hook1","hook2","ShepherdFactory","starrySky","UFO","ship","saucer","cockpit","interior","ShipFactory","alien","armLeft","armRight","arms","eyeLeft","eyeRight","AlienFactory","beam","outer","inner","BeamFactory","UFOFactory","Animations","bunchOfGrapes","AmbientLight","unleashCurse","curseUnleahsed","brighten","toggleCurse","newLight","earthquake","toggleEarthquake","dancingGrapes","dancing","rave","ferrisWheel","toggleDancing","toggleRave","toggleferrisWheel","grape","shepherdAbilities","angle","toggleFlying","flying","toggleLeft","rightTurn","leftTurn","toggleRight","camelInternalAnimation","camelHeadBob","objectsToAffect","toggleAnimation","moveCamera","moving","toggleMoving","camelInScene","timeBetween","changeView","isPerspective","toggleView","orthographicCamera","perspectiveCamera","facetedAnimation","sceneObject","sceneToggleFaceted","thingsWeWant","toggleUnleshCurse","toggleCamelAnimation","makeWireframe","toggleMoveCamera","changeCamera","ExampleWebGL","Sandbox","IceCream","sphere","cone","IceCreamFactory","grapes","camel","cylinder","OurSandbox","Greeting","App","className","activeClassName","to","path","component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bc278048.chunk.js","sourcesContent":["// return type that points to itself\n// geos gotta know their size slurpq!\n\n/*\n * This module defines/generates vertex arrays for certain predefined shapes.\n * The \"shapes\" are returned as indexed vertices, with utility functions for\n * converting these into \"raw\" coordinate arrays.\n */\n\n/**\n * Returns the vertices and faces for a small icosahedron.\n *\n * Lets call the resulting data structure a proto-geometry because it has\n * the beginnings of a geometry but nothing close to what three.js has (yet).\n */\nconst icosahedron = () => {\n  // The core icosahedron coordinates.\n  const X = 0.525731112119133606\n  const Z = 0.850650808352039932\n\n  return {\n    type: icosahedron,\n    params: {},\n    vertices: [\n      [-X, 0.0, Z],\n      [X, 0.0, Z],\n      [-X, 0.0, -Z],\n      [X, 0.0, -Z],\n      [0.0, Z, X],\n      [0.0, Z, -X],\n      [0.0, -Z, X],\n      [0.0, -Z, -X],\n      [Z, X, 0.0],\n      [-Z, X, 0.0],\n      [Z, -X, 0.0],\n      [-Z, -X, 0.0]\n    ],\n\n    facesByIndex: [\n      [1, 4, 0],\n      [4, 9, 0],\n      [4, 5, 9],\n      [8, 5, 4],\n      [1, 8, 4],\n      [1, 10, 8],\n      [10, 3, 8],\n      [8, 3, 5],\n      [3, 2, 5],\n      [3, 7, 2],\n      [3, 10, 7],\n      [10, 6, 7],\n      [6, 11, 7],\n      [6, 0, 11],\n      [6, 1, 0],\n      [10, 1, 6],\n      [11, 0, 9],\n      [2, 11, 9],\n      [5, 2, 9],\n      [11, 2, 7]\n    ]\n  }\n}\n\n/*\nCone\n*/\n\nconst Cone = (radius = 0.5, height = 1, radialSegments = 32, heightSegments = 32) => {\n  const deltaRotation = (2 * Math.PI) / radialSegments\n  const deltaHeight = height / heightSegments\n  const deltaRadius = (deltaHeight * radius) / height\n\n  const vertices = []\n  vertices.push([0, 0, 0])\n  for (let i = -heightSegments / 2; i <= heightSegments / 2; i++) {\n    for (let j = 0; j <= radialSegments; j++) {\n      vertices.push([radius * Math.sin(j * deltaRotation), i * deltaHeight, radius * Math.cos(j * deltaRotation)])\n    }\n    radius -= deltaRadius\n  }\n\n  const facesByIndex = []\n  // BASE:\n  for (let i = 0; i < radialSegments; i++) {\n    //facesByIndex.push([0,i+1,(i+2) % radialSegments])\n    facesByIndex.push([0, i + 1, i + 2])\n  }\n\n  // CONE:\n  for (let i = 1; i < vertices.length - radialSegments - 1; i++) {\n    facesByIndex.push([i, i + 1, i + radialSegments + 1])\n    facesByIndex.push([i, i + radialSegments + 1, i + radialSegments])\n  }\n\n  return { params: { radius, height, radialSegments, heightSegments, type: Cone }, vertices, facesByIndex }\n}\n\n/*\nCylinder - Extra (based on lathe)\n*/\n\nconst Cylinder = (radius = 0.5, height = 0.5, radialSegments = 32, heightSegments = 32, closed = true) => {\n  const deltaRotation = (2 * Math.PI) / radialSegments\n  const deltaHeight = (1.0 * height) / heightSegments\n\n  const vertices = []\n  for (let i = 0; i <= heightSegments; i++) {\n    for (let j = 0; j <= radialSegments; j++) {\n      vertices.push([radius * Math.sin(j * deltaRotation), radius * Math.cos(j * deltaRotation), i * deltaHeight])\n    }\n  }\n\n  const facesByIndex = []\n  for (let i = 0; i < vertices.length - radialSegments - 1; i++) {\n    facesByIndex.push([i + radialSegments + 1, i + 1, i])\n    facesByIndex.push([i, i + radialSegments, i + radialSegments + 1])\n  }\n\n  //Add top/bottom if necessary\n  if (closed) {\n    const vertexOffset = vertices.length - radialSegments\n    //Add center of bottom circle\n    vertices.push([0, 0, 0])\n    for (let i = 0; i < radialSegments; i++) {\n      //add bottom circle for cylinder\n      facesByIndex.push([i, (i + 1) % radialSegments, vertices.length - 1])\n    }\n\n    //Add center of top circle\n    vertices.push([0, 0, deltaHeight * heightSegments])\n    for (let i = 0; i < radialSegments; i++) {\n      //add top circle for cylinder\n      facesByIndex.push([vertices.length - 1, vertexOffset + ((i + 1) % radialSegments), vertexOffset + i])\n    }\n  }\n\n  return { params: { radius, height, radialSegments, heightSegments, type: Cylinder }, vertices, facesByIndex }\n}\n\n/*\nExtrudeGeometry takes vertices2D, which is\na path of 2D coordinates ordered counter-clockwise,\nand faces2D, or the indexes of vertices2D grouped\ninto faces (3 vertices ordered counter-clockwise).\nThe 2D shape formed by the vertices is then\nextruded by the depth to form a 3D geometry.\n*/\n\nconst Extrude = (vertices2D, faces2D, depth = 0.5) => {\n  let vertices = (function createVertices(vertices2D, depth) {\n    let vertices = []\n    //splits the 2D vertices into front and back faces\n    for (let i = 0; i < vertices2D.length; i++) {\n      vertices.splice(i, 0, [...vertices2D[i], -depth / 2])\n      vertices.push([...vertices2D[i], depth / 2])\n    }\n    return vertices\n  })(vertices2D, depth)\n\n  let facesByIndex = (function createFacesByIndex(vertices, faces2D) {\n    let facesByIndex = []\n    const half = vertices.length / 2\n    //splits the front and back faces into triangles using 2D faces\n    for (let i = 0; i < faces2D.length; i++) {\n      facesByIndex.push(faces2D[i])\n      facesByIndex.push([faces2D[i][0] + half, faces2D[i][2] + half, faces2D[i][1] + half])\n    }\n    /* connects the front and back faces with rectangular\n    sides each formed by 2 triangles */\n    for (let i = 0; i < half; i++) {\n      facesByIndex.push([i, i + half, (i + 1) % half])\n      facesByIndex.push([i + 1, i + half, (i + half + 1) % (half * 2)])\n    }\n    return facesByIndex\n  })(vertices, faces2D)\n\n  return { params: { vertices2D, faces2D, depth, type: Extrude }, vertices, facesByIndex }\n}\n\n/*\nLathe\n*/\n\nconst Lathe = (points, segments = 32, phiStart = 0, phiLength = 2 * Math.PI) => {\n  /**\n   * Lathe rotates points by phiLength amount, starting at phiStart creating segments number of segments\n   * It does this about the z-axis, assuming point is a [radius, height] tuple in array form\n   */\n\n  const rotationPerSegment = phiLength / segments\n\n  const vertices = []\n  points.forEach(givenPoint => {\n    for (let i = 0; i <= segments; i++) {\n      vertices.push([\n        givenPoint[0] * Math.sin(phiStart + i * rotationPerSegment),\n        givenPoint[0] * Math.cos(phiStart + i * rotationPerSegment),\n        givenPoint[1]\n      ])\n    }\n  })\n\n  const facesByIndex = []\n  for (let i = 0; i < vertices.length - segments - 1; i++) {\n    facesByIndex.push([i + segments + 1, i + 1, i])\n    facesByIndex.push([i, i + segments, i + segments + 1])\n  }\n\n  return {\n    params: { points, segments, phiStart, phiLength, type: Lathe },\n    vertices,\n    facesByIndex\n  }\n}\n\n/*\n  Regular Polygon\n*/\n\nconst RegularPolygon = numberOfSides => {\n  let vertices = (function createVertices(numberOfPoints, radius = 1) {\n    let vertices = []\n    let increment = (2 * Math.PI) / numberOfPoints\n    vertices.push([0, 0, 0])\n    for (let i = 0; i < numberOfPoints; i++) {\n      vertices.push([Math.cos(i * increment) * radius, Math.sin(i * increment) * radius, 0])\n    }\n    return vertices\n  })(numberOfSides)\n\n  let facesByIndex = []\n  for (let i = 1; i <= numberOfSides; i++) {\n    if (i < numberOfSides) {\n      facesByIndex.push([0, i, i + 1])\n    } else {\n      facesByIndex.push([0, i, 1])\n    }\n  }\n  return { params: { numberOfSides, type: RegularPolygon }, vertices, facesByIndex }\n}\n\n/*\nSphere\n*/\n\nconst Sphere = (radius = 0.5, radialSegments = 32) => {\n  const deltaRotation = (2 * Math.PI) / radialSegments\n  const deltaRadius = radius / radialSegments\n  let currentRadius = radius\n\n  const vertices = []\n  for (let i = 0; i <= radialSegments; i++) {\n    currentRadius = Math.sqrt(radius ** 2 - (i * deltaRadius) ** 2)\n    for (let j = 0; j <= radialSegments; j++) {\n      vertices.push([\n        currentRadius * Math.sin(j * deltaRotation),\n        currentRadius * Math.cos(j * deltaRotation),\n        i * deltaRadius\n      ])\n    }\n  }\n\n  for (let i = 0; i <= radialSegments; i++) {\n    currentRadius = Math.sqrt(radius ** 2 - (i * deltaRadius) ** 2)\n    for (let j = 0; j <= radialSegments; j++) {\n      vertices.push([\n        currentRadius * Math.sin(j * deltaRotation),\n        currentRadius * Math.cos(j * deltaRotation),\n        -i * deltaRadius\n      ])\n    }\n  }\n\n  const facesByIndex = []\n\n  for (let i = 0; i < vertices.length - radialSegments - 1; i++) {\n    if (i <= (vertices.length - radialSegments - 1) / 2) {\n      facesByIndex.push([i + 1, i, i + radialSegments + 1])\n      facesByIndex.push([i + radialSegments + 1, i, i + radialSegments])\n    } else {\n      facesByIndex.push([i, i + 1, i + radialSegments + 1])\n      facesByIndex.push([i, i + radialSegments + 1, i + radialSegments])\n    }\n  }\n\n  return { params: { radius, radialSegments, type: Sphere }, vertices, facesByIndex }\n}\n\n/**\n * Torus arcs a tube with radius tubeRadius around a given innerRadius with arc defaulted to 2 PI.\n * radialSegments & tubularSegments adjust depth & roundness of the tube, respectively.\n */\n\nconst Torus = (innerRadius = 0.5, tubeRadius = 0.2, radialSegments = 36, tubularSegments = 36, arc = Math.PI * 2) => {\n  const vertices = []\n\n  for (let i = 0; i <= radialSegments; i++) {\n    for (let j = 0; j <= tubularSegments; j++) {\n      const u = (j / tubularSegments) * arc\n      const v = (i / radialSegments) * Math.PI * 2\n\n      vertices.push([\n        (innerRadius + tubeRadius * Math.cos(v)) * Math.cos(u),\n        (innerRadius + tubeRadius * Math.cos(v)) * Math.sin(u),\n        tubeRadius * Math.sin(v)\n      ])\n    }\n  }\n\n  const facesByIndex = []\n\n  for (let i = 1; i <= radialSegments; i++) {\n    for (let j = 1; j <= tubularSegments; j++) {\n      facesByIndex.push([\n        (tubularSegments + 1) * i + j - 1,\n        (tubularSegments + 1) * (i - 1) + j - 1,\n        (tubularSegments + 1) * i + j\n      ])\n      facesByIndex.push([\n        (tubularSegments + 1) * (i - 1) + j - 1,\n        (tubularSegments + 1) * (i - 1) + j,\n        (tubularSegments + 1) * i + j\n      ])\n    }\n  }\n  return {\n    params: { innerRadius, tubeRadius, radialSegments, tubularSegments, arc, type: Torus },\n    vertices,\n    facesByIndex\n  }\n}\n\n/*\n  Tube is two Cylinder objects, one nested inside the other, connected by faces\n*/\n\nconst Tube = (innerRadius = 0.1, outerRadius = 0.6, height = 0.5, radialSegments = 24, heightSegments = 32) => {\n  const deltaRotation = (2 * Math.PI) / radialSegments\n  const deltaHeight = height / heightSegments\n\n  const vertices = []\n  const cylinderVertices = heightSegments * (radialSegments + 1)\n\n  // Outer cylinder\n  for (let i = 0; i < heightSegments; i++) {\n    for (let j = 0; j <= radialSegments; j++) {\n      vertices.push([\n        outerRadius * Math.sin(j * deltaRotation),\n        outerRadius * Math.cos(j * deltaRotation),\n        i * deltaHeight\n      ])\n    }\n  }\n\n  // Inner cylinder\n  for (let i = 0; i < heightSegments; i++) {\n    for (let j = 0; j <= radialSegments; j++) {\n      vertices.push([\n        innerRadius * Math.sin(j * deltaRotation),\n        innerRadius * Math.cos(j * deltaRotation),\n        i * deltaHeight\n      ])\n    }\n  }\n\n  const facesByIndex = []\n  for (let i = 0; i < cylinderVertices - radialSegments - 1; i++) {\n    facesByIndex.push([i, i + 1, i + radialSegments + 1])\n    facesByIndex.push([i, i + radialSegments + 1, i + radialSegments])\n  }\n\n  for (let i = cylinderVertices; i < vertices.length - radialSegments - 1; i++) {\n    facesByIndex.push([i, i + 1, i + radialSegments + 1])\n    facesByIndex.push([i, i + radialSegments + 1, i + radialSegments])\n  }\n\n  //Add top/bottom\n  for (let j = 0; j <= radialSegments; j++) {\n    vertices.push([innerRadius * Math.sin(j * deltaRotation), innerRadius * Math.cos(j * deltaRotation), 0])\n  }\n\n  for (let j = 0; j <= radialSegments; j++) {\n    vertices.push([outerRadius * Math.sin(j * deltaRotation), outerRadius * Math.cos(j * deltaRotation), 0])\n  }\n\n  for (let i = cylinderVertices * 2; i < cylinderVertices * 2 + radialSegments + 1; i++) {\n    facesByIndex.push([i, i + radialSegments, i + radialSegments + 1])\n    facesByIndex.push([i, i + 1, i + radialSegments + 1])\n  }\n\n  //Add top/bottom if necessary\n  for (let j = 0; j <= radialSegments; j++) {\n    vertices.push([\n      innerRadius * Math.sin(j * deltaRotation),\n      innerRadius * Math.cos(j * deltaRotation),\n      height - deltaHeight\n    ])\n  }\n\n  for (let j = 0; j <= radialSegments; j++) {\n    vertices.push([\n      outerRadius * Math.sin(j * deltaRotation),\n      outerRadius * Math.cos(j * deltaRotation),\n      height - deltaHeight\n    ])\n  }\n\n  for (let i = cylinderVertices * 2 + 2 * radialSegments; i < cylinderVertices * 2 + 3 * radialSegments + 3; i++) {\n    facesByIndex.push([i, i + radialSegments, i + radialSegments + 1])\n    facesByIndex.push([i, i + 1, i + radialSegments + 1])\n  }\n\n  return {\n    params: { innerRadius, outerRadius, height, radialSegments, heightSegments, type: Tube },\n    vertices,\n    facesByIndex\n  }\n}\n\nexport { icosahedron, Cone, Cylinder, Extrude, Lathe, RegularPolygon, Sphere, Torus, Tube }\n","/*\n * This is a set of utility functions that are common across many types of WebGL programs.\n * Dont feel beholden to how this is structured---feel free to take it apart and rearrange\n * things into something that makes more sense to you.\n */\n\n/**\n * Returns the WebGL rendering context.\n */\nconst getGL = canvas => canvas.getContext('webgl')\n\n/**\n * Initializes a vertex buffer for the given array of vertices.\n */\nconst initVertexBuffer = (gl, vertices) => {\n  const buffer = gl.createBuffer()\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW)\n  return buffer\n}\n\n/**\n * Sets up a GLSL shader of the given type.\n */\nconst compileShader = (gl, shaderSource, shaderType, compileError) => {\n  const shader = gl.createShader(shaderType)\n  gl.shaderSource(shader, shaderSource)\n  gl.compileShader(shader)\n\n  // Check for an error.\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    if (compileError) {\n      compileError(shader)\n    }\n\n    return null\n  } else {\n    return shader\n  }\n}\n\n/**\n * Links a GLSL program.\n */\nconst linkShaderProgram = (gl, vertexShader, fragmentShader) => {\n  const shaderProgram = gl.createProgram()\n  gl.attachShader(shaderProgram, vertexShader)\n  gl.attachShader(shaderProgram, fragmentShader)\n  gl.linkProgram(shaderProgram)\n  return shaderProgram\n}\n\n/**\n * Initializes a simple shader program, using these parameters:\n *\n * - gl: The WebGL context to use.\n * - vertexShaderSource: The vertex shader source code.\n * - fragmentShaderSource: The fragment shader source code.\n *\n * Optional parameters:\n *\n * - compileError: The function to call if a shader does not compile.\n * - linkError: The function to call if the program does not link.\n */\nconst initSimpleShaderProgram = (gl, vertexShaderSource, fragmentShaderSource, compileError, linkError) => {\n  const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER, compileError)\n  const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER, compileError)\n\n  // If either shader is null, we just bail out.  An error would have\n  // been reported to the compileError function.\n  if (!vertexShader || !fragmentShader) {\n    return null\n  }\n\n  // Link the shader program.\n  const shaderProgram = linkShaderProgram(gl, vertexShader, fragmentShader)\n  if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    return shaderProgram\n  }\n\n  // If we get here, something must have gone wrong.\n  if (linkError) {\n    linkError(shaderProgram)\n  }\n\n  return null\n}\n\nexport { getGL, initVertexBuffer, compileShader, linkShaderProgram, initSimpleShaderProgram }\n","/*\n\n    A basic 44 matrix object that initializes, by default, to the identity matrix\n    Matrix multiplication\n    Collection of 3D matrix implementations (contributed individually)\n        3D translation\n        3D scale\n        3D rotation about on an arbitrary axis (you may refactor the sample code to fit your matrix object implementation)\n        Orthographic projection\n        Perspective (frustum) projection\n    Conversion/convenience functions to prepare the matrix data for direct consumption by WebGL and GLSL\n\n*/\n\n/*\nRow Column form note:\nhttps://en.wikipedia.org/wiki/Row-_and_column-major_order\n\n*/\n\nconst MatrixLibrary = {\n\n  identityMatrix: () => {\n    return Matrix()\n  },\n\n  scaleMatrix: (width, height, depth) => {\n    // prettier-ignore\n    return Matrix([\n      [width,      0,     0, 0],\n      [    0, height,     0, 0],\n      [    0,      0, depth, 0],\n      [    0,      0,     0, 1]\n    ])\n  },\n\n  translationMatrix: (x, y, z) => {\n    return Matrix([\n      [1, 0, 0, x],\n      [0, 1, 0, y],\n      [0, 0, 1, z],\n      [0, 0, 0, 1]\n    ])\n  },\n\n  rotationMatrix: (x, y, z) => {\n    // prettier-ignore\n    const xRotationMatrix = Matrix([\n      [1,           0,            0, 0],\n      [0, Math.cos(x), -Math.sin(x), 0],\n      [0, Math.sin(x),  Math.cos(x), 0],\n      [0,           0,            0, 1]\n    ])\n    // prettier-ignore\n    const yRotationMatrix = Matrix([\n      [ Math.cos(y), 0, Math.sin(y), 0],\n      [           0, 1,           0, 0],\n      [-Math.sin(y), 0, Math.cos(y), 0],\n      [           0, 0,           0, 1]\n    ])\n    // prettier-ignore\n    const zRotationMatrix = Matrix([\n      [Math.cos(z), -Math.sin(z), 0, 0],\n      [Math.sin(z),  Math.cos(z), 0, 0],\n      [          0,            0, 1, 0],\n      [          0,            0, 0, 1]\n    ])\n    return xRotationMatrix.multiply(yRotationMatrix.multiply(zRotationMatrix))\n  },\n\n  orthographicProjectionMatrix: (top=1, bottom=-1, right=1, left=-1, near=1, far=-1) => {\n    // prettier-ignore\n    return Matrix([\n      [2/(right - left),                0,                  0, -((right + left)/(right - left))],\n      [               0, (2/(top-bottom)),                  0, -((top+bottom)/(top - bottom))  ],\n      [               0,                0,  -(2/(far - near)), -(far + near)/(far - near)      ],\n      [               0,                0,                  0,                                1]\n    ])\n  },\n\n  perspectiveMatrix: (top, bottom, right, left, near, far) => {\n    return Matrix([\n      [(2*near)/(right-left),                     0, (right+left)/(right-left),                        0],\n      [                    0, (2*near)/(top-bottom), (top+bottom)/(top-bottom),                        0],\n      [                    0,                     0,    -((far+near)/(far-near)), -((2*far*near)/(far-near))],\n      [                    0,                     0,                        -1,                        0]\n    ])\n  },\n  rotateAboutPoint : (point = [0, 0, 0], rotation = [0, 0, 0]) => {\n    return MatrixLibrary.translationMatrix(...point)\n      .multiply(MatrixLibrary.rotationMatrix(...rotation))\n      .multiply(MatrixLibrary.translationMatrix(...point.map(element => -element)))\n  }\n}\n\nconst Matrix = initialValue => {\n  let elements = initialValue\n    ? initialValue\n    : [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1]\n      ]\n\n  let rows = elements.length\n  let columns = elements[0].length\n\n  const getRows = () => {\n    return rows\n  }\n\n  const getColumns = () => {\n    return columns\n  }\n\n  const toArray = () => {\n    //Convert to column-major order\n    if (rows <= 0 || columns <= 0) return []\n\n    const resultArray = []\n\n    for (let column = 0; column < columns; column++) {\n      for (let row = 0; row < rows; row++) {\n        resultArray.push(elements[row][column])\n      }\n    }\n    return resultArray\n  }\n\n  const scalarMultiply = (scalar) => {\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < columns; col++) {\n        elements[row][col] *= scalar\n      }\n    }\n    return Matrix(elements)\n  }\n\n  const multiply = otherMatrix => {\n    //TODO cleanup\n    if (\n      !otherMatrix ||\n      !Array.isArray(otherMatrix.elements) ||\n      elements.length <= 0 ||\n      otherMatrix.elements.length <= 0 ||\n      elements[0].length <= 0 ||\n      otherMatrix.elements[0].length <= 0\n    ) {\n      throw new Error('Cannot multiply matrices ')\n    } else if (otherMatrix.elements.length !== elements[0].length) {\n      throw new Error('Matrix is incompatible for multiplication')\n    }\n\n    let rowProduct = Array.apply(null, new Array(otherMatrix.elements[0].length)).map(Number.prototype.valueOf, 0)\n    let result = new Array(elements.length)\n    for (let row = 0; row < elements.length; row++) {\n      result[row] = rowProduct.slice()\n    }\n\n    for (let aRow = 0; aRow < elements.length; aRow++) {\n      for (let bRow = 0; bRow < otherMatrix.elements[0].length; bRow++) {\n        for (let col = 0; col < elements[0].length; col++) {\n          result[aRow][bRow] += elements[aRow][col] * otherMatrix.elements[col][bRow]\n        }\n      }\n    }\n\n    return Matrix(result)\n  }\n\n  return {\n    elements,\n    getRows,\n    getColumns,\n    scalarMultiply,\n    multiply,\n    toArray\n  }\n}\n\nexport { Matrix, MatrixLibrary }\n","import { useState, useEffect, useRef } from 'react'\n\nimport { getGL, initVertexBuffer, initSimpleShaderProgram } from './glsl-utilities'\n// import { polygon, icosahedron, toRawLineArray, toRawTriangleArray } from './shapes'\n// import { Our3DObject, OurMesh, Our3DGroup, OurCamera, OurLight } from './Our3DObject'\n// import { Cone, Cylinder, Extrude, RegularPolygon, Sphere, Tube, Torus } from './GeometryLibrary'\nimport { Matrix, MatrixLibrary } from './OurMatrix'\n// import { BigBang, Scene } from './OurUniverse'\n// import { universeFromJson } from './UniverseFromJson'\n// import exampleScene from './scenes/exampleScene.json'\n// import {sphinx} from './objects/sphinx.js'\n\n// Slightly-leveled-up GLSL shaders.\nconst VERTEX_SHADER = `\n  #ifdef GL_ES\n  precision highp float;\n  #endif\n\n  attribute vec3 vertexPosition;\n  attribute vec3 normals;\n\n  // Note this new additional output.\n  attribute vec3 vertexColor;\n  varying vec4 finalVertexColor;\n  uniform vec3 lightDirection;\n  uniform vec3 lightColor;\n\n  // uniform vec3 lightsDirections[3];\n  // uniform vec3 lightsColor[3];\n  uniform vec3 ambientLight;\n\n  uniform mat4 matrix;\n  uniform mat4 cameraMatrix;\n  uniform mat4 projectionMatrix;\n\n  void main(void) {\n    \n    // vec4 transformedNormal = cameraMatrix * matrix * vec4(normals, 0.0);\n    // vec3 finalFakeNormal = normalize(transformedVertex.xyz);\n    // float cosineBetween = dot(lightVector, finalFakeNormal);\n    // vec3 reflection = 2.0 * cosineBetween * finalFakeNormal - lightVector;\n    // vec3 specularBaseColor = vec3(1.0, 1.0, 1.0);\n    // float shininess = 5.0;\n    // float specularContribution = pow(max(dot(reflection, transformedVertex.xyz), 0.0), shininess);\n    // if (cosineBetween < 0.0) {\n    //   specularBaseColor = vec3(0.0, 0.0, 0.0);\n    // }\n    //finalVertexColor = vec4(lightContribution * lightColor * vertexColor + specularContribution * specularBaseColor, 1.0);\n    \n\n    // Directional lights\n    // vec3 reflectedLightColor;\n    // for(int i = 0; i < 3; i++){\n    //   reflectedLightColor += max(dot(lightVector, normalize(normals)),0.0);\n    // }\n\n    vec4 transformedVertex = cameraMatrix * matrix * vec4(vertexPosition, 1.0);\n    vec4 transformedNormals = cameraMatrix * matrix * vec4(normals, 0.0);\n    vec3 lightVector = normalize(lightDirection - transformedVertex.xyz);\n    float directionalLightContribution = max(dot(lightVector, normalize(transformedNormals.xyz)), 0.0);\n    gl_Position = cameraMatrix * matrix * vec4(vertexPosition, 1.0);\n    finalVertexColor = vec4((directionalLightContribution * lightColor + ambientLight) * vertexColor, 1.0);\n  }\n`\n\nconst FRAGMENT_SHADER = `\n  #ifdef GL_ES\n  precision highp float;\n  #endif\n\n  varying vec4 finalVertexColor;\n\n  void main(void) {\n    // We vary the color based on the fragment's z coordinate,\n    // which, at this point, ranges from 0 (near) to 1 (far).\n    // Note the \".rgb\" subselector.\n    gl_FragColor = vec4((1.0 - gl_FragCoord.z) * finalVertexColor.rgb, 1.0);\n  }\n`\nconst useInitWebGL = universe => {\n  const canvasRef = useRef()\n\n  const [animationWrapper, setanimationWrapper] = useState(null)\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) {\n      return\n    }\n\n    // Grab the WebGL rendering context.\n    const gl = getGL(canvas)\n    if (!gl) {\n      alert('No WebGL context found...sorry.')\n\n      // No WebGL, no use going on...\n      return\n    }\n\n    // Set up settings that will not change.  This is not \"canned\" into a\n    // utility function because these settings really can vary from program\n    // to program.\n    gl.enable(gl.DEPTH_TEST)\n    gl.clearColor(0.0, 0.0, 0.0, 0.0)\n    gl.viewport(0, 0, canvas.width, canvas.height)\n\n    // Build the objects to display.\n    // const objectsToDraw = universe.scene.objectsToDraw\n\n    // Pass the vertices to WebGL.\n    // objectsToDraw.forEach(objectToDraw => {\n    //   objectToDraw.verticesBuffer = initVertexBuffer(gl, objectToDraw.vertices)\n    //   objectToDraw.normalsBuffer = initVertexBuffer(gl, objectToDraw.normals)\n    //   objectToDraw.colorsBuffer = initVertexBuffer(gl, objectToDraw.colors)\n    // })\n\n    // Initialize the shaders.\n    let abort = false\n    const shaderProgram = initSimpleShaderProgram(\n      gl,\n      VERTEX_SHADER,\n      FRAGMENT_SHADER,\n\n      // Very cursory error-checking here...\n      shader => {\n        abort = true\n        alert('Shader problem: ' + gl.getShaderInfoLog(shader))\n      },\n\n      // Another simplistic error check: we don't even access the faulty\n      // shader program.\n      shaderProgram => {\n        abort = true\n        alert('Could not link shaders...sorry.')\n      }\n    )\n\n    // If the abort variable is true here, we can't continue.\n    if (abort) {\n      alert('Fatal errors encountered; we cannot continue.')\n      return\n    }\n\n    // All done --- tell WebGL to use the shader program from now on.\n    gl.useProgram(shaderProgram)\n\n    // Hold on to the important variables within the shaders.\n    const vertexPosition = gl.getAttribLocation(shaderProgram, 'vertexPosition')\n    gl.enableVertexAttribArray(vertexPosition)\n\n    const vertexColor = gl.getAttribLocation(shaderProgram, 'vertexColor')\n    gl.enableVertexAttribArray(vertexColor)\n\n    const normals = gl.getAttribLocation(shaderProgram, 'normals')\n    gl.enableVertexAttribArray(normals)\n\n    const matrix = gl.getUniformLocation(shaderProgram, 'matrix')\n    const projectionMatrix = gl.getUniformLocation(shaderProgram, 'projectionMatrix')\n    const cameraMatrix = gl.getUniformLocation(shaderProgram, 'cameraMatrix')\n\n    const lightDirection = gl.getUniformLocation(shaderProgram, 'lightDirection')\n    const lightColor = gl.getUniformLocation(shaderProgram, 'lightColor')\n\n    const ambientLight = gl.getUniformLocation(shaderProgram, 'ambientLight')\n\n    /*\n     * Displays an individual object.\n     */\n    const drawObject = object => {\n      if (object.change) {\n        object.verticesBuffer = initVertexBuffer(gl, object.vertices)\n        object.normalsBuffer = initVertexBuffer(gl, object.normals)\n        object.colorsBuffer = initVertexBuffer(gl, object.colors)\n\n        object.change = false\n      }\n      // Set up the rotation matrix.\n      object.transform(Matrix())\n      //object.transform(parentMatrix)\n      gl.uniformMatrix4fv(matrix, gl.FALSE, object.matrix.toArray())\n\n      // Set normals\n      gl.bindBuffer(gl.ARRAY_BUFFER, object.normalsBuffer)\n      gl.vertexAttribPointer(normals, 3, gl.FLOAT, false, 0, 0)\n\n      // Set the varying colors.\n      gl.bindBuffer(gl.ARRAY_BUFFER, object.colorsBuffer)\n      gl.vertexAttribPointer(vertexColor, 3, gl.FLOAT, false, 0, 0)\n\n      // Set the varying vertex coordinates.\n      gl.bindBuffer(gl.ARRAY_BUFFER, object.verticesBuffer)\n      gl.vertexAttribPointer(vertexPosition, 3, gl.FLOAT, false, 0, 0)\n      gl.drawArrays(object.mesh.isWireframe ? gl.LINES : gl.TRIANGLES, 0, object.vertices.length / 3)\n    }\n\n    /*\n     * Displays the scene.\n     */\n\n    const drawScene = () => {\n      // Clear the display.\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n\n      // Set up projection matrix\n      gl.uniformMatrix4fv(\n        projectionMatrix,\n        gl.FALSE,\n        MatrixLibrary.orthographicProjectionMatrix(-1, 1, -1, 1, -1, 1).toArray()\n      )\n      gl.uniformMatrix4fv(cameraMatrix, gl.FALSE, universe.scene.camera.matrix)\n      gl.uniform3fv(lightDirection, new Float32Array(universe.scene.light.direction))\n      gl.uniform3fv(lightColor, new Float32Array(universe.scene.light.color))\n      gl.uniform3fv(\n        ambientLight,\n        new Float32Array(universe.scene.ambientLight ? universe.scene.ambientLight.color : [0, 0, 0])\n      )\n\n      // Display the objects.\n      universe.scene.objectsToDraw.forEach(drawObject)\n\n      // All done.\n      gl.flush()\n    }\n\n    /*\n    Directions say 'static scene'\n    /*\n     * Animates the scene.\n     */\n    let previousTimestamp = null\n\n    const FRAMES_PER_SECOND = 60\n    const MILLISECONDS_PER_FRAME = 1000 / FRAMES_PER_SECOND\n\n    const advanceScene = timestamp => {\n      // Check if the user has turned things off.\n\n      // Initialize the timestamp.\n      if (!previousTimestamp) {\n        previousTimestamp = timestamp\n        window.requestAnimationFrame(advanceScene)\n        return\n      }\n\n      // Check if it's time to advance.\n      var progress = timestamp - previousTimestamp\n      if (progress < MILLISECONDS_PER_FRAME) {\n        // Do nothing if it's too soon.\n        window.requestAnimationFrame(advanceScene)\n        return\n      }\n\n      // All clear.\n      universe?.tick(progress)\n      drawScene()\n\n      // Request the next frame.\n      previousTimestamp = timestamp\n      window.requestAnimationFrame(advanceScene)\n    }\n\n    // Draw the initial scene.\n    drawScene()\n\n    setanimationWrapper({\n      startAnimation: () => {\n        previousTimestamp = null\n        window.requestAnimationFrame(advanceScene)\n      }\n    })\n  }, [canvasRef, universe])\n\n  return { canvasRef, animationWrapper }\n}\n\nconst ReactWebGL = props => {\n  const { canvasRef, animationWrapper } = useInitWebGL(props.universe)\n\n  const handleClick = event => {\n    props.universe.click()\n  }\n\n  // Auto-start animations\n  useEffect(() => {\n    if (animationWrapper) {\n      animationWrapper.startAnimation()\n    }\n  }, [animationWrapper])\n\n  return (\n    <article>\n      <canvas width=\"1024\" height=\"512\" ref={canvasRef} onClick={animationWrapper && handleClick}>\n        Your favorite update-your-browser message here.\n      </canvas>\n    </article>\n  )\n}\n\nexport { useInitWebGL, ReactWebGL }\n","/**\n * This JavaScript module defines a Vector object and associated functions.\n *\n * The modules approach is non-destructive: methods always return new\n * Vector objects and never modify the operands. This is a design choice.\n *\n * The module is designed for vectors of any number of dimensions. The\n * implementations are generalized but not optimal for certain sizes of\n * vectors. Specific Vector2D and Vector3D implementations can be much\n * more compact, while sacrificing generality.\n */\n\n// THANKS @ DONDI !!!! \n\n/**\n * A private method for checking dimensions, throwing an exception when different.\n */\n const checkDimensions = (v1, v2) => {\n  if (v1.dimensions !== v2.dimensions) {\n    throw Error('Vectors have different dimensions')\n  }\n}\n\n// Define the class.\nclass Vector {\n  constructor() {\n    this.elements = [].slice.call(arguments)\n  }\n\n  get dimensions() {\n    return this.elements.length\n  }\n\n  get x() {\n    return this.elements[0]\n  }\n\n  get y() {\n    return this.elements[1]\n  }\n\n  get z() {\n    return this.elements[2]\n  }\n\n  get w() {\n    return this.elements[3]\n  }\n\n  add(v) {\n    let result = new Vector()\n\n    checkDimensions(this, v)\n\n    for (let i = 0, max = this.dimensions; i < max; i += 1) {\n      result.elements[i] = this.elements[i] + v.elements[i]\n    }\n\n    return result\n  }\n\n  subtract(v) {\n    let result = new Vector()\n\n    checkDimensions(this, v)\n\n    for (let i = 0, max = this.dimensions; i < max; i += 1) {\n      result.elements[i] = this.elements[i] - v.elements[i]\n    }\n\n    return result\n  }\n\n  multiply(s) {\n    let result = new Vector()\n\n    for (let i = 0, max = this.dimensions; i < max; i += 1) {\n      result.elements[i] = this.elements[i] * s\n    }\n\n    return result\n  }\n\n  divide(s) {\n    let result = new Vector()\n\n    for (let i = 0, max = this.dimensions; i < max; i += 1) {\n      result.elements[i] = this.elements[i] / s\n    }\n\n    return result\n  }\n\n  dot(v) {\n    let result = 0\n\n    checkDimensions(this, v)\n\n    for (let i = 0, max = this.dimensions; i < max; i += 1) {\n      result += this.elements[i] * v.elements[i]\n    }\n\n    return result\n  }\n\n  cross(v) {\n    if (this.dimensions !== 3 || v.dimensions !== 3) {\n      throw Error('Cross product is for 3D vectors only.')\n    }\n\n    // With 3D vectors, we can just return the result directly.\n    return new Vector(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x)\n  }\n\n  get magnitude() {\n    return Math.sqrt(this.dot(this))\n  }\n\n  get unit() {\n    // At this point, we can leverage our more \"primitive\" methods.\n    return this.divide(this.magnitude)\n  }\n\n  normalize(){\n    return this.divide(this.magnitude)\n  }\n\n  projection(v) {\n    checkDimensions(this, v)\n\n    // Plug and chug :)\n    // The projection of u onto v is u dot the unit vector of v\n    // times the unit vector of v.\n    let unitv = v.unit\n    return unitv.multiply(this.dot(unitv))\n  }\n}\n\n\n/**\n * Utility function for turning our nascent geometry object into a raw coordinate array\n * arranged as triangles.\n */\n const toRawTriangleArray = protoGeometry => {\n  const result = []\n\n  protoGeometry.facesByIndex.forEach(face => {\n    face.forEach(vertexIndex => {\n      result.push(...protoGeometry.vertices[vertexIndex])\n    })\n  })\n\n  return result\n}\n\n/*\n * Utility function for turning indexed vertices into a raw coordinate array\n * arranged as line segments.\n */\nconst toRawLineArray = protoGeometry => {\n  const result = []\n\n  protoGeometry.facesByIndex.forEach(face => {\n    // Oddly enough, the inner loop here is clearer as a `for` loop because we\n    // need to access the current vertex index and the one after that (wrapping\n    // around once we get to the end).\n    for (let i = 0, maxI = face.length; i < maxI; i += 1) {\n      // Connect the dots.\n      result.push(\n        ...protoGeometry.vertices[face[i]],\n        ...protoGeometry.vertices[face[(i + 1) % maxI]] // Lets us wrap around to 0.\n      )\n    }\n  })\n\n  return result\n}\n\nexport { Vector, toRawLineArray, toRawTriangleArray }\n","import { MatrixLibrary } from './OurMatrix'\n\n\n// Just an 'apply' for our Transform\nconst Transform = (object, matrix) => {\n  object.transform(matrix);\n}\n\nconst Translate = (object, x, y, z) => {\n  Transform(object, MatrixLibrary.translationMatrix(x, y, z))\n}\n\nconst Rotate = (object, x, y, z) => {\n  Transform(object, MatrixLibrary.rotationMatrix(x, y, z))\n}\n\nconst Scale = (object, width, height, depth) => {\n  Transform(object, MatrixLibrary.scaleMatrix(width, height, depth))\n}\n\nconst RotateAboutPoint = (object, point, rotation) => {\n  Transform(object, MatrixLibrary.rotateAboutPoint(point, rotation))\n}\n\nconst TransformableObject = () => {\n  // A method to add 'transform' functions to our objects\n  // a way to do a parent class without actually doing a parent class\n  return {\n    translate: function (x, y, z) {\n      Translate(this, x, y, z)\n      return this\n    },\n    rotate: function (x, y, z) {\n      Rotate(this, x, y, z)\n      return this\n    },\n    scale: function (width, height, depth) {\n      Scale(this, width, height, depth)\n      return this\n    },\n    rotateAboutPoint: function (point, rotation) {\n      RotateAboutPoint(this, point, rotation)\n      return this;\n    }\n  }\n}\n\nexport { TransformableObject, Translate, Rotate, Scale, Transform, RotateAboutPoint }","import { toRawLineArray, toRawTriangleArray, Vector } from './OurUtilities'\nimport { Matrix, MatrixLibrary } from './OurMatrix'\nimport { TransformableObject } from './OurTransformations'\n\n// TODO Caching for normals / vertices\nconst OurMesh = ({ vertices, facesByIndex }, wireframe = false, faceted = false) => {\n  let isWireframe = wireframe\n  let isFaceted = faceted\n\n  let cachedVertices = false // the vertices to return\n  let cachedNormals = false // the normals to return\n\n  let cachedFacetedWireframeNormals = false // the normals when faceted and isWireframe\n  let cachedSmoothWireframeNormals = false // normals when smooth and isWireframe\n  let cachedFacetedFacesNormals = false // normals when faceted and not is wireframe\n  let cachedSmoothFacesNormals = false // normals when smooth and not is wireframe\n\n  let cachedWireframeVertices = false // vertices when wireframe\n  let cachedNotWireframeVertices = false // vertices when not is wireframe\n\n  return {\n    change: true,\n    facesByIndex,\n    facesChanged: false,\n    get vertices() {\n      if (!cachedVertices) {\n        this.updateCachedVertices()\n      }\n      return cachedVertices\n    },\n    set vertices(newCachedVertices) {\n      cachedVertices = newCachedVertices\n    },\n    updateCachedVertices: function () {\n      // We assume that those who change between wireframe and not\n      // are going to do so multiple times\n      // this is a bold assumption but,,, memory is cheaper than these vertex calculations\n      // however, this is a moderately more efficient calculation than normals\n      // so only two caches\n      if (isWireframe) {\n        if (!cachedWireframeVertices || this.facesChanged) {\n          cachedWireframeVertices = toRawLineArray({ vertices, facesByIndex })\n          this.facesChanged = false\n        }\n        cachedVertices = cachedWireframeVertices\n      } else {\n        if (!cachedNotWireframeVertices || this.facesChanged) {\n          cachedNotWireframeVertices = toRawTriangleArray({ vertices, facesByIndex })\n          this.facesChanged = false\n        }\n        cachedVertices = cachedNotWireframeVertices\n      }\n      // this.vertices = cachedVertices\n      // cachedVertices = isWireframe ? toRawLineArray({ vertices, facesByIndex }) : toRawTriangleArray({ vertices, facesByIndex })\n      this.change = true\n    },\n    get rawVertices() {\n      return vertices\n    },\n    get isWireframe() {\n      return isWireframe\n    },\n    set isWireframe(newIsWireframe) {\n      isWireframe = newIsWireframe\n      this.updateCachedVertices()\n      this.updateCachedNormals()\n    },\n    setWireframe: function (newIsWireframe) {\n      //backwards compatibility\n      isWireframe = newIsWireframe\n      this.updateCachedVertices()\n      this.updateCachedNormals()\n      return this\n    },\n\n    set isFaceted(newFaceted) {\n      this.facesChanged = true\n      isFaceted = newFaceted\n      this.updateCachedNormals()\n    },\n    get isFaceted() {\n      return isFaceted\n    },\n    setIsFaceted: function (newVal) {\n      this.facesChanged = true\n      isFaceted = newVal\n      this.updateCachedNormals()\n      this.updateCachedVertices()\n      return this\n    },\n    toggleIsFaceted:function(){\n      this.setIsFaceted(!isFaceted)\n      return this\n    },\n    get normals() {\n      if (!cachedNormals) {\n        this.updateCachedNormals()\n      }\n      return cachedNormals\n    },\n    updateCachedNormals: function () {\n      // If user switches, higher likelihood they will switch multiple times\n      // normals calculations are SLOW\n      // so just keep the cache, memory is cheaper than normal calculations\n      // caches ALL normals if they are requested once\n\n      if (this.isFaceted) {\n        if (this.isWireframe) {\n          if (!cachedFacetedWireframeNormals) {\n            cachedFacetedWireframeNormals = this.facetedNormals\n          }\n          cachedNormals = cachedFacetedWireframeNormals\n        } else {\n          if (!cachedFacetedFacesNormals) {\n            cachedFacetedFacesNormals = this.facetedNormals\n          }\n          cachedNormals = cachedFacetedFacesNormals\n        }\n      } else {\n        if (this.isWireframe) {\n          if (!cachedSmoothWireframeNormals) {\n            cachedSmoothWireframeNormals = this.smoothNormals\n          }\n          cachedNormals = cachedSmoothWireframeNormals\n        } else {\n          if (!cachedSmoothFacesNormals) {\n            cachedSmoothFacesNormals = this.smoothNormals\n          }\n          cachedNormals = cachedSmoothFacesNormals\n        }\n      }\n      this.change = true\n      // cachedNormals = isFaceted ? this.facetedNormals : this.smoothNormals\n    },\n\n    get normalsByFace() {\n      // Kept purely for its educational value!\n      // this will be rolled into 'helperNormals' eventually\n      // because calculating separate from 'by vertex' is a waste\n      const normalsByFace = []\n      // Matches facesByIndex in parallel\n\n      facesByIndex.forEach(face => {\n        // p1-p0 x p2-p0\n        let n = new Vector(\n          this.rawVertices[face[1]][0] - this.rawVertices[face[0]][0],\n          this.rawVertices[face[1]][1] - this.rawVertices[face[0]][1],\n          this.rawVertices[face[1]][2] - this.rawVertices[face[0]][2]\n        ).cross(\n          new Vector(\n            this.rawVertices[face[2]][0] - this.rawVertices[face[0]][0],\n            this.rawVertices[face[2]][1] - this.rawVertices[face[0]][1],\n            this.rawVertices[face[2]][2] - this.rawVertices[face[0]][2]\n          )\n        )\n        normalsByFace.push(n)\n      })\n      return normalsByFace\n    },\n\n    get normalsByRawVertex() {\n      // Sum of normals at a vertex\n      const normalsByRawVertex = Array(this.rawVertices.length).fill(new Vector(0, 0, 0))\n      facesByIndex.forEach(face => {\n        let v1 = new Vector(\n          this.rawVertices[face[1]][0] - this.rawVertices[face[0]][0],\n          this.rawVertices[face[1]][1] - this.rawVertices[face[0]][1],\n          this.rawVertices[face[1]][2] - this.rawVertices[face[0]][2]\n        )\n        let v2 = new Vector(\n          this.rawVertices[face[2]][0] - this.rawVertices[face[0]][0],\n          this.rawVertices[face[2]][1] - this.rawVertices[face[0]][1],\n          this.rawVertices[face[2]][2] - this.rawVertices[face[0]][2]\n        )\n        let n = v2.cross(v1)\n        normalsByRawVertex[face[0]] = normalsByRawVertex[face[0]].add(n)\n        normalsByRawVertex[face[1]] = normalsByRawVertex[face[1]].add(n)\n        normalsByRawVertex[face[2]] = normalsByRawVertex[face[2]].add(n)\n      })\n      return normalsByRawVertex\n    },\n\n    get facetedNormals() {\n      // We could use 'normalsByFace' for this\n      // but i think this is moderatey more efficient :)\n      // and doesn't require weird mapping from byFace to byVertex\n      const normalsByVertex = []\n      if (!this.isWireframe) {\n        for (let i = 0; i < this.vertices.length; i += 9) {\n          let n = new Vector(\n            this.vertices[i + 6] - this.vertices[i + 0],\n            this.vertices[i + 7] - this.vertices[i + 1],\n            this.vertices[i + 8] - this.vertices[i + 2]\n          ).cross(\n            new Vector(\n              this.vertices[i + 3] - this.vertices[i + 0],\n              this.vertices[i + 4] - this.vertices[i + 1],\n              this.vertices[i + 5] - this.vertices[i + 2]\n            )\n          )\n          normalsByVertex.push(n.x, n.y, n.z) // Corresponding to vertex 0 of this face\n          normalsByVertex.push(n.x, n.y, n.z)\n          normalsByVertex.push(n.x, n.y, n.z)\n        }\n      } else {\n        for (let i = 0; i < this.vertices.length; i += 18) {\n          //         0       2       4 vertices\n          // indices 0,1,2 : 6,7,8 : 12 13 14\n          // 6 vertices per face (double counted as each line is 2 vertices)\n          let n = new Vector(\n            this.vertices[i + 6] - this.vertices[i + 0],\n            this.vertices[i + 7] - this.vertices[i + 1],\n            this.vertices[i + 8] - this.vertices[i + 2]\n          ).cross(\n            new Vector(\n              this.vertices[i + 12] - this.vertices[i + 0],\n              this.vertices[i + 13] - this.vertices[i + 1],\n              this.vertices[i + 14] - this.vertices[i + 2]\n            )\n          )\n          normalsByVertex.push(\n            n.x,\n            n.y,\n            n.z, // Corresponding to vertex 0 of this face\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z\n          )\n        }\n      }\n      return normalsByVertex\n    },\n\n    get smoothNormals() {\n      const normalsByVertex = []\n      if (!this.isWireframe) {\n        facesByIndex.forEach(face => {\n          face.forEach(vertexIndex => {\n            normalsByVertex.push(\n              this.normalsByRawVertex[vertexIndex].x,\n              this.normalsByRawVertex[vertexIndex].y,\n              this.normalsByRawVertex[vertexIndex].z\n            )\n          })\n        })\n      } else {\n        facesByIndex.forEach(face => {\n          for (let i = 0, maxI = face.length; i < maxI; i += 1) {\n            normalsByVertex.push(...this.normalsByRawVertex[i].elements)\n            normalsByVertex.push(...this.normalsByRawVertex[i].elements)\n          }\n        })\n      }\n      return normalsByVertex\n    }\n  }\n}\n\nconst Our3DObject = (mesh, colorArray = [0, 0, 0], name = 'A 3D Object') => {\n  let matrix = Matrix()\n  let cachedColors\n  let change = true\n\n  return {\n    ...TransformableObject(),\n    type: Our3DObject,\n    set change(newVal) {\n      change = newVal\n      this.mesh.change = newVal\n    },\n    get change() {\n      return change || this.mesh.change\n    },\n    name,\n    mesh,\n    get vertices() {\n      return mesh.vertices\n    },\n    get matrix() {\n      return matrix\n    },\n    get color() {\n      return this.colors //backwards compatibility\n    },\n    set colors(newColorArray) {\n      colorArray = newColorArray\n      cachedColors = this.calcColors()\n    },\n    get colors() {\n      if (!cachedColors) {\n        cachedColors = this.calcColors()\n      }\n      return cachedColors\n    },\n    calcColors: function () {\n      let colors = []\n      if (Array.isArray(colorArray[0]) && colorArray.length === this.mesh.facesByIndex.length) {\n        if (!this.mesh.isWireframe) {\n          // if they wish to pass color by face and it is NOT writeframe\n          for (let i = 0, maxi = this.vertices.length / 9; i < maxi; i += 1) {\n            for (let j = 0; j < 3; j++) {\n              colors.push(colorArray[i][0])\n              colors.push(colorArray[i][1])\n              colors.push(colorArray[i][2])\n            }\n          }\n        } else {\n          // they wish to pass color by face BUT its a wireframe (ahh)\n          // this obviously cant display /that/ well because one line ALWAYS borders two faces\n          // so one object needs two colors? huh? so it logically can't display well\n          // this is simply added so that .toWireframe doesn't break the entire program\n          for (let faceIndex = 0; faceIndex < this.mesh.facesByIndex.length; faceIndex++) {\n            for (let i = 0, maxI = this.mesh.facesByIndex[faceIndex].length; i < maxI; i += 1) {\n              colors.push(...colorArray[faceIndex])\n              colors.push(...colorArray[faceIndex])\n            }\n          }\n        }\n      } else if (Array.isArray(colorArray[0]) && colorArray.length === this.mesh.rawVertices.length) {\n        // color by vertex\n        if (!this.mesh.isWireframe) {\n          this.mesh.facesByIndex.forEach(face => {\n            face.forEach(vertexIndex => {\n              colors.push(...colorArray[vertexIndex])\n            })\n          })\n        } else {\n          this.mesh.facesByIndex.forEach(face => {\n            for (let i = 0, maxI = face.length; i < maxI; i += 1) {\n              // Connect the dots.\n              colors.push(\n                ...colorArray[face[i]],\n                ...colorArray[face[(i + 1) % maxI]] // Lets us wrap around to 0.\n              )\n            }\n          })\n        }\n      } else if (Array.isArray(colorArray[0])) {\n        // poorly shaped size ; rather than explode, we will choose the first colour\n        // this is a CHOICE and this entire else-if can be removed to force errors for poorly sized colour arrays\n        for (let i = 0, maxi = this.vertices.length / 3; i < maxi; i += 1) {\n          colors = colors.concat(colorArray[0][0], colorArray[0][1], colorArray[0][2])\n        }\n      } else {\n        for (let i = 0, maxi = this.vertices.length / 3; i < maxi; i += 1) {\n          colors = colors.concat(colorArray[0], colorArray[1], colorArray[2])\n        }\n      }\n      this.change = true\n      return colors\n    },\n    get normals() {\n      return mesh.normals\n    },\n    setColors: function (newColorArray) {\n      colorArray = newColorArray\n      cachedColors = this.calcColors()\n      return this\n    },\n    setRandomColors: function (n = 4, byVertex = true) {\n      colorArray = []\n      if (byVertex) {\n        for (let i = 0; i < mesh.rawVertices.length; i++) {\n          colorArray.push([Math.random() * n, Math.random() * n, Math.random() * n])\n        }\n      } else {\n        for (let i = 0; i < mesh.facesByIndex.length; i++) {\n          colorArray.push([Math.random() * n, Math.random() * n, Math.random() * n])\n        }\n      }\n      cachedColors = this.calcColors()\n      return this\n    },\n    toggleIsFaceted: function(){\n      return this.toggleFaceted()\n    },\n    toggleFaceted: function () {\n      this.mesh.toggleIsFaceted()\n      return this;\n    },\n    setIsFaceted: function (newVal) {\n      this.mesh.setIsFaceted(newVal)\n      return this\n    },\n    get isFaceted() {\n      return mesh.isFaceted\n    },\n    set isFaceted(newValue) {\n      mesh.isFaceted = newValue\n    },\n    set isWireframe(newVal) {\n      mesh.isWireframe = newVal\n      cachedColors = this.calcColors()\n    },\n    get isWireframe() {\n      return mesh.isWireframe\n    },\n    toggleWireframe: function () {\n      this.setWireframe(!this.isWireframe)\n    },\n    setWireframe: function (newIsWireframe) {\n      mesh.setWireframe(newIsWireframe)\n      cachedColors = this.calcColors()\n      return this\n    },\n    transform: function (transformMatrix) {\n      matrix = transformMatrix.multiply(matrix)\n      return this\n    },\n    transformVertices: function (otherMatrix) {\n      mesh.vertices = mesh.rawVertices.map(vertex =>\n        otherMatrix\n          .multiply(Matrix([[vertex[0]], [vertex[1]], [vertex[2]], [1]]))\n          .toArray()\n          .slice(0, -1)\n      )\n      return this\n    }\n  }\n}\n\nconst Our3DGroup = (objects = [], name = 'A 3D Group') => {\n  let group = []\n  if (objects) {\n    group = group.concat(objects)\n  }\n  let matrix = Matrix()\n  return {\n    ...TransformableObject(),\n    get self() {\n      return this\n    },\n    get group() {\n      return group\n    },\n    get flatGroup() {\n      const results = []\n        .concat(this.group.filter(element => element.type === Our3DObject).flatMap(element => element))\n        .concat(\n          this.group\n            .filter(element => element.type === Our3DGroup)\n            .map(element => element.flatGroup)\n            .flatMap(element => element)\n        )\n      return results\n    },\n    set group(newVal) {\n      group = newVal\n    },\n    name,\n    set change(newVal) {\n      this.group.forEach(object => (object.change = newVal))\n    },\n    get change() {\n      for (let object of group) {\n        if (object.change) {\n          return true\n        }\n      }\n      return false\n    },\n    get matrix() {\n      return matrix\n    },\n    type: Our3DGroup,\n    add: function (object) {\n      group.push(object)\n      return this\n    },\n    remove: function (object) {\n      this.group = this.group.filter(groupObject => groupObject !== object)\n      this.group.filter(element => element.type === Our3DGroup).forEach(nestedGroup => nestedGroup.remove(object))\n      return this\n    },\n    transform: function (transformMatrix) {\n      group.forEach(object => object.transform(transformMatrix))\n      return this\n    },\n    setColors: function (newColorArray) {\n      group.forEach(object => object.setColors(newColorArray))\n      return this\n    },\n    toggleWireframe: function () {\n      group.forEach(object => object.toggleWireframe())\n    },\n    setWireframe: function (newIsWireframe) {\n      group.forEach(object => object.setWireframe(newIsWireframe))\n      return this\n    },\n    setRandomColors: function (n = 5, byVertex = true) {\n      group.forEach(object => object.setRandomColors(n, byVertex))\n      return this\n    },\n    transformVertices: function (transformMatrix) {\n      group.forEach(object => object.transformVertices(transformMatrix))\n      return this\n    },\n    set isFaceted(newVal) {\n      group.forEach(object => (object.isFaceted = newVal))\n    },\n    setIsFaceted: function (newVal) {\n      group.forEach(object => object.setIsFaceted(newVal))\n      return this\n    },\n    toggleFaceted: function () {\n      group.forEach(object => object.toggleFaceted())\n      return this\n    },\n    getObjectByName: function (searchName) {\n      if (group.find(element => element.name === searchName))\n        return group\n          .filter(element => element.type === Our3DObject || element.type === Our3DGroup)\n          .find(element => element.name === searchName)\n      else {\n        return group\n          .filter(element => element.type === Our3DGroup)\n          .map(element => element.getObjectByName(searchName))\n          .filter(element => element !== undefined)\n          .flatMap(element => element)[0]\n      }\n    }\n  }\n}\n\nconst OurLight = (direction = [0, 0, 0], color = [1, 1, 1]) => {\n  return {\n    type: OurLight,\n    direction: direction,\n    color: color\n  }\n}\n\nconst OurAmbientLight = (color = [1, 1, 1]) => {\n  return {\n    type: OurAmbientLight,\n    color,\n    set newLight(newColor = [1, 1, 1]) {\n      this.color = newColor\n    }\n  }\n}\n\nconst OurCamera = (center, direction, projectionOptions, projectionType = MatrixLibrary.perspectiveMatrix) => {\n  let matrix = Matrix()\n    .multiply(MatrixLibrary.translationMatrix(center[0], center[1], center[2]))\n    .multiply(MatrixLibrary.rotationMatrix(direction[0], direction[1], direction[2]))\n\n  const projectionMatrix = projectionType(...projectionOptions)\n\n  return {\n    ...TransformableObject(),\n    type: OurCamera,\n    get matrix() {\n      return projectionMatrix.multiply(matrix).toArray()\n    },\n    set matrix(newMatrix) {\n      matrix = newMatrix\n    },\n    translate: function (x, y, z) {\n      matrix = matrix.multiply(MatrixLibrary.translationMatrix(x, y, z))\n      return this\n    },\n    rotate: function (x, y, z) {\n      matrix = matrix.multiply(MatrixLibrary.rotationMatrix(x, y, z))\n      return this\n    },\n    projectionMatrix\n  }\n}\n\nexport { OurAmbientLight, OurMesh, Our3DGroup, Our3DObject, OurLight, OurCamera }\n","import * as Geometries from './OurGeometryLibrary'\nimport { Matrix, MatrixLibrary } from './OurMatrix'\nimport { toRawLineArray, toRawTriangleArray, Vector } from './OurUtilities'\nimport { TransformableObject } from './OurTransformations'\nimport { Our3DObject } from './Our3DObject'\n\nconst scaleFactor = (mesh, cachedMesh) => {\n  if (mesh === cachedMesh || mesh.type === Geometries.icosahedron) {\n    return MatrixLibrary.scaleMatrix(1, 1, 1)\n  }\n\n  if (mesh.geometry.type === Geometries.Cylinder || mesh.geometry.type === Geometries.Cone) {\n    const xFactor = mesh.geometry.radius / cachedMesh.geometry.radius\n    const yFactor = xFactor\n    const zFactor = mesh.geometry.height / cachedMesh.geometry.height\n    return MatrixLibrary.scaleMatrix(xFactor, yFactor, zFactor)\n  } else if (mesh.geometry.type === Geometries.Sphere) {\n    const factor = mesh.geometry.radius / cachedMesh.geometry.radius\n    return MatrixLibrary.scaleMatrix(factor, factor, factor)\n  } else if (mesh.geometry.type === Geometries.Tube) {\n    const zFactor = mesh.geometry.height / cachedMesh.geometry.height\n    return MatrixLibrary.scaleMatrix(1, 1, zFactor)\n  }\n\n  // default if Geometry caching not supported\n  return MatrixLibrary.scaleMatrix(1, 1, 1)\n}\n\nconst cachedMeshes = []\nconst searchForCachedMesh = mesh => {\n  // Torus was lowkey complicated since innerRadius & tubeRadius affect e/o...\n  // so we're not gonna worry ab it since we're refactoring on Thursday of finals week lol\n  if (\n    mesh.geometry.type === Geometries.Lathe ||\n    mesh.geometry.type === Geometries.Extrude ||\n    mesh.geometry.type === Geometries.Torus\n  ) {\n    return mesh\n  }\n\n  // Cache search: same type, normals, & vertices check\n  let result = cachedMeshes.find(\n    cachedMesh =>\n      cachedMesh.geometry.type === mesh.geometry.type &&\n      cachedMesh.isWireframe === mesh.isWireframe &&\n      cachedMesh.isFaceted === mesh.isFaceted &&\n      (mesh.geometry.type !== Geometries.RegularPolygon ||\n        mesh.geometry.numberOfSides === cachedMesh.geometry.numberOfSides) &&\n      ((mesh.geometry.type !== Geometries.Cylinder &&\n        mesh.geometry.type !== Geometries.Cone &&\n        mesh.geometry.type !== Geometries.Sphere &&\n        mesh.geometry.type !== Geometries.Tube) ||\n        mesh.geometry.radialSegments === cachedMesh.geometry.radialSegments) &&\n      ((mesh.geometry.type !== Geometries.Cylinder && mesh.geometry.type !== Geometries.Cone) ||\n        mesh.geometry.heightSegments === cachedMesh.geometry.heightSegments) &&\n      (mesh.geometry.type !== Geometries.Tube ||\n        (mesh.geometry.innerRadius === cachedMesh.geometry.innerRadius &&\n          mesh.geometry.outerRadius === cachedMesh.geometry.outerRadius))\n  )\n\n  if (result) {\n    console.log('Cache hit')\n    return result\n  } else {\n    cachedMeshes.push(mesh)\n    return mesh\n  }\n}\n\nconst OurCachedMesh = ({ vertices, facesByIndex, params }, wireframe = false, faceted = false) => {\n  let isWireframe = wireframe\n  let isFaceted = faceted\n\n  let cachedVertices = false // the vertices to return\n  let cachedNormals = false // the normals to return\n\n  let cachedFacetedWireframeNormals = false // the normals when faceted and isWireframe\n  let cachedSmoothWireframeNormals = false // normals when smooth and isWireframe\n  let cachedFacetedFacesNormals = false // normals when faceted and not is wireframe\n  let cachedSmoothFacesNormals = false // normals when smooth and not is wireframe\n\n  let cachedWireframeVertices = false // vertices when wireframe\n  let cachedNotWireframeVertices = false // vertices when not is wireframe\n\n  return {\n    change: true,\n    facesByIndex,\n    geometry: params,\n    facesChanged: false,\n    get vertices() {\n      if (!cachedVertices) {\n        this.updateCachedVertices()\n      }\n      return cachedVertices\n    },\n    set vertices(newCachedVertices) {\n      cachedVertices = newCachedVertices\n    },\n    updateCachedVertices: function () {\n      // We assume that those who change between wireframe and not\n      // are going to do so multiple times\n      // this is a bold assumption but,,, memory is cheaper than these vertex calculations\n      // however, this is a moderately more efficient calculation than normals\n      // so only two caches\n      if (isWireframe) {\n        if (!cachedWireframeVertices || this.facesChanged) {\n          cachedWireframeVertices = toRawLineArray({ vertices, facesByIndex })\n          this.facesChanged = false\n        }\n        cachedVertices = cachedWireframeVertices\n      } else {\n        if (!cachedNotWireframeVertices || this.facesChanged) {\n          cachedNotWireframeVertices = toRawTriangleArray({ vertices, facesByIndex })\n          this.facesChanged = false\n        }\n        cachedVertices = cachedNotWireframeVertices\n      }\n      // this.vertices = cachedVertices\n      // cachedVertices = isWireframe ? toRawLineArray({ vertices, facesByIndex }) : toRawTriangleArray({ vertices, facesByIndex })\n      this.change = true\n    },\n    get rawVertices() {\n      return vertices\n    },\n    get isWireframe() {\n      return isWireframe\n    },\n    set isWireframe(newIsWireframe) {\n      isWireframe = newIsWireframe\n      this.updateCachedVertices()\n      this.updateCachedNormals()\n    },\n    setWireframe: function (newIsWireframe) {\n      //backwards compatibility\n      isWireframe = newIsWireframe\n      this.updateCachedVertices()\n      this.updateCachedNormals()\n      return this\n    },\n\n    set isFaceted(newFaceted) {\n      this.facesChanged = true\n      isFaceted = newFaceted\n      this.updateCachedNormals()\n    },\n    get isFaceted() {\n      return isFaceted\n    },\n    setIsFaceted: function (newVal) {\n      this.facesChanged = true\n      isFaceted = newVal\n      this.updateCachedNormals()\n      this.updateCachedVertices()\n      return this\n    },\n    toggleIsFaceted: function () {\n      this.setIsFaceted(!isFaceted)\n      return this\n    },\n    get normals() {\n      if (!cachedNormals) {\n        this.updateCachedNormals()\n      }\n      return cachedNormals\n    },\n    updateCachedNormals: function () {\n      // If user switches, higher likelihood they will switch multiple times\n      // normals calculations are SLOW\n      // so just keep the cache, memory is cheaper than normal calculations\n      // caches ALL normals if they are requested once\n\n      if (this.isFaceted) {\n        if (this.isWireframe) {\n          if (!cachedFacetedWireframeNormals) {\n            cachedFacetedWireframeNormals = this.facetedNormals\n          }\n          cachedNormals = cachedFacetedWireframeNormals\n        } else {\n          if (!cachedFacetedFacesNormals) {\n            cachedFacetedFacesNormals = this.facetedNormals\n          }\n          cachedNormals = cachedFacetedFacesNormals\n        }\n      } else {\n        if (this.isWireframe) {\n          if (!cachedSmoothWireframeNormals) {\n            cachedSmoothWireframeNormals = this.smoothNormals\n          }\n          cachedNormals = cachedSmoothWireframeNormals\n        } else {\n          if (!cachedSmoothFacesNormals) {\n            cachedSmoothFacesNormals = this.smoothNormals\n          }\n          cachedNormals = cachedSmoothFacesNormals\n        }\n      }\n      this.change = true\n      // cachedNormals = isFaceted ? this.facetedNormals : this.smoothNormals\n    },\n\n    get normalsByFace() {\n      // Kept purely for its educational value!\n      // this will be rolled into 'helperNormals' eventually\n      // because calculating separate from 'by vertex' is a waste\n      const normalsByFace = []\n      // Matches facesByIndex in parallel\n\n      facesByIndex.forEach(face => {\n        // p1-p0 x p2-p0\n        let n = new Vector(\n          this.rawVertices[face[1]][0] - this.rawVertices[face[0]][0],\n          this.rawVertices[face[1]][1] - this.rawVertices[face[0]][1],\n          this.rawVertices[face[1]][2] - this.rawVertices[face[0]][2]\n        ).cross(\n          new Vector(\n            this.rawVertices[face[2]][0] - this.rawVertices[face[0]][0],\n            this.rawVertices[face[2]][1] - this.rawVertices[face[0]][1],\n            this.rawVertices[face[2]][2] - this.rawVertices[face[0]][2]\n          )\n        )\n        normalsByFace.push(n)\n      })\n      return normalsByFace\n    },\n\n    get normalsByRawVertex() {\n      // Sum of normals at a vertex\n      const normalsByRawVertex = Array(this.rawVertices.length).fill(new Vector(0, 0, 0))\n      facesByIndex.forEach(face => {\n        let v1 = new Vector(\n          this.rawVertices[face[1]][0] - this.rawVertices[face[0]][0],\n          this.rawVertices[face[1]][1] - this.rawVertices[face[0]][1],\n          this.rawVertices[face[1]][2] - this.rawVertices[face[0]][2]\n        )\n        let v2 = new Vector(\n          this.rawVertices[face[2]][0] - this.rawVertices[face[0]][0],\n          this.rawVertices[face[2]][1] - this.rawVertices[face[0]][1],\n          this.rawVertices[face[2]][2] - this.rawVertices[face[0]][2]\n        )\n        let n = v2.cross(v1)\n        normalsByRawVertex[face[0]] = normalsByRawVertex[face[0]].add(n)\n        normalsByRawVertex[face[1]] = normalsByRawVertex[face[1]].add(n)\n        normalsByRawVertex[face[2]] = normalsByRawVertex[face[2]].add(n)\n      })\n      return normalsByRawVertex\n    },\n\n    get facetedNormals() {\n      // We could use 'normalsByFace' for this\n      // but i think this is moderatey more efficient :)\n      // and doesn't require weird mapping from byFace to byVertex\n      const normalsByVertex = []\n      if (!this.isWireframe) {\n        for (let i = 0; i < this.vertices.length; i += 9) {\n          let n = new Vector(\n            this.vertices[i + 6] - this.vertices[i + 0],\n            this.vertices[i + 7] - this.vertices[i + 1],\n            this.vertices[i + 8] - this.vertices[i + 2]\n          ).cross(\n            new Vector(\n              this.vertices[i + 3] - this.vertices[i + 0],\n              this.vertices[i + 4] - this.vertices[i + 1],\n              this.vertices[i + 5] - this.vertices[i + 2]\n            )\n          )\n          normalsByVertex.push(n.x, n.y, n.z) // Corresponding to vertex 0 of this face\n          normalsByVertex.push(n.x, n.y, n.z)\n          normalsByVertex.push(n.x, n.y, n.z)\n        }\n      } else {\n        for (let i = 0; i < this.vertices.length; i += 18) {\n          //         0       2       4 vertices\n          // indices 0,1,2 : 6,7,8 : 12 13 14\n          // 6 vertices per face (double counted as each line is 2 vertices)\n          let n = new Vector(\n            this.vertices[i + 6] - this.vertices[i + 0],\n            this.vertices[i + 7] - this.vertices[i + 1],\n            this.vertices[i + 8] - this.vertices[i + 2]\n          ).cross(\n            new Vector(\n              this.vertices[i + 12] - this.vertices[i + 0],\n              this.vertices[i + 13] - this.vertices[i + 1],\n              this.vertices[i + 14] - this.vertices[i + 2]\n            )\n          )\n          normalsByVertex.push(\n            n.x,\n            n.y,\n            n.z, // Corresponding to vertex 0 of this face\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z,\n            n.x,\n            n.y,\n            n.z\n          )\n        }\n      }\n      return normalsByVertex\n    },\n\n    get smoothNormals() {\n      const normalsByVertex = []\n      if (!this.isWireframe) {\n        facesByIndex.forEach(face => {\n          face.forEach(vertexIndex => {\n            normalsByVertex.push(\n              this.normalsByRawVertex[vertexIndex].x,\n              this.normalsByRawVertex[vertexIndex].y,\n              this.normalsByRawVertex[vertexIndex].z\n            )\n          })\n        })\n      } else {\n        facesByIndex.forEach(face => {\n          for (let i = 0, maxI = face.length; i < maxI; i += 1) {\n            normalsByVertex.push(...this.normalsByRawVertex[i].elements)\n            normalsByVertex.push(...this.normalsByRawVertex[i].elements)\n          }\n        })\n      }\n      return normalsByVertex\n    }\n  }\n}\n\nconst OurCachedObject = (mesh, colorArray = [0, 0, 0], name = 'A 3D Object') => {\n  let matrix = Matrix()\n  let cachedColors = false\n  let change = true\n  let cachedMesh\n\n  if (mesh.geometry) {\n    // caching logic requires geometry information\n    cachedMesh = searchForCachedMesh(mesh)\n  } else {\n    cachedMesh = mesh\n  }\n\n  const OurObject = {\n    ...TransformableObject(),\n    type: Our3DObject,\n    set change(newVal) {\n      change = newVal\n      this.mesh.change = newVal\n    },\n    get change() {\n      return change || this.mesh.change\n    },\n    name,\n    mesh: cachedMesh,\n    get vertices() {\n      return mesh.vertices\n    },\n    get matrix() {\n      return matrix\n    },\n    get color() {\n      return this.colors //backwards compatibility\n    },\n    set colors(newColorArray) {\n      colorArray = newColorArray\n      cachedColors = this.calcColors()\n    },\n    get colors() {\n      if (!cachedColors) {\n        cachedColors = this.calcColors()\n      }\n      return cachedColors\n    },\n    calcColors: function () {\n      let colors = []\n      if (Array.isArray(colorArray[0]) && colorArray.length === this.mesh.facesByIndex.length) {\n        if (!this.mesh.isWireframe) {\n          // if they wish to pass color by face and it is NOT writeframe\n          for (let i = 0, maxi = this.vertices.length / 9; i < maxi; i += 1) {\n            for (let j = 0; j < 3; j++) {\n              colors.push(colorArray[i][0])\n              colors.push(colorArray[i][1])\n              colors.push(colorArray[i][2])\n            }\n          }\n        } else {\n          // they wish to pass color by face BUT its a wireframe (ahh)\n          // this obviously cant display /that/ well because one line ALWAYS borders two faces\n          // so one object needs two colors? huh? so it logically can't display well\n          // this is simply added so that .toWireframe doesn't break the entire program\n          for (let faceIndex = 0; faceIndex < this.mesh.facesByIndex.length; faceIndex++) {\n            for (let i = 0, maxI = this.mesh.facesByIndex[faceIndex].length; i < maxI; i += 1) {\n              colors.push(...colorArray[faceIndex])\n              colors.push(...colorArray[faceIndex])\n            }\n          }\n        }\n      } else if (Array.isArray(colorArray[0]) && colorArray.length === this.mesh.rawVertices.length) {\n        // color by vertex\n        if (!this.mesh.isWireframe) {\n          this.mesh.facesByIndex.forEach(face => {\n            face.forEach(vertexIndex => {\n              colors.push(...colorArray[vertexIndex])\n            })\n          })\n        } else {\n          this.mesh.facesByIndex.forEach(face => {\n            for (let i = 0, maxI = face.length; i < maxI; i += 1) {\n              // Connect the dots.\n              colors.push(\n                ...colorArray[face[i]],\n                ...colorArray[face[(i + 1) % maxI]] // Lets us wrap around to 0.\n              )\n            }\n          })\n        }\n      } else if (Array.isArray(colorArray[0])) {\n        // poorly shaped size ; rather than explode, we will choose the first colour\n        // this is a CHOICE and this entire else-if can be removed to force errors for poorly sized colour arrays\n        for (let i = 0, maxi = this.vertices.length / 3; i < maxi; i += 1) {\n          colors = colors.concat(colorArray[0][0], colorArray[0][1], colorArray[0][2])\n        }\n      } else {\n        for (let i = 0, maxi = this.vertices.length / 3; i < maxi; i += 1) {\n          colors = colors.concat(colorArray[0], colorArray[1], colorArray[2])\n        }\n      }\n      this.change = true\n      return colors\n    },\n    get normals() {\n      return mesh.normals\n    },\n    setColors: function (newColorArray) {\n      colorArray = newColorArray\n      cachedColors = this.calcColors()\n      return this\n    },\n    setRandomColors: function (n = 4, byVertex = true) {\n      colorArray = []\n      if (byVertex) {\n        for (let i = 0; i < mesh.rawVertices.length; i++) {\n          colorArray.push([Math.random() * n, Math.random() * n, Math.random() * n])\n        }\n      } else {\n        for (let i = 0; i < mesh.facesByIndex.length; i++) {\n          colorArray.push([Math.random() * n, Math.random() * n, Math.random() * n])\n        }\n      }\n      cachedColors = this.calcColors()\n      return this\n    },\n    toggleIsFaceted: function () {\n      return this.toggleFaceted()\n    },\n    toggleFaceted: function () {\n      this.mesh.toggleIsFaceted()\n      return this\n    },\n    setIsFaceted: function (newVal) {\n      this.mesh.setIsFaceted(newVal)\n      return this\n    },\n    get isFaceted() {\n      return mesh.isFaceted\n    },\n    set isFaceted(newValue) {\n      mesh.isFaceted = newValue\n    },\n    set isWireframe(newVal) {\n      mesh.isWireframe = newVal\n      cachedColors = this.calcColors()\n    },\n    get isWireframe() {\n      return mesh.isWireframe\n    },\n    toggleWireframe: function () {\n      this.setWireframe(!this.isWireframe)\n    },\n    setWireframe: function (newIsWireframe) {\n      mesh.setWireframe(newIsWireframe)\n      cachedColors = this.calcColors()\n      return this\n    },\n    transform: function (transformMatrix) {\n      matrix = transformMatrix.multiply(matrix)\n      return this\n    },\n    transformVertices: function (otherMatrix) {\n      mesh.vertices = mesh.rawVertices.map(vertex =>\n        otherMatrix\n          .multiply(Matrix([[vertex[0]], [vertex[1]], [vertex[2]], [1]]))\n          .toArray()\n          .slice(0, -1)\n      )\n      return this\n    }\n  }\n\n  OurObject.transform(scaleFactor(mesh, cachedMesh))\n  return OurObject\n}\n\nexport { OurCachedObject, OurCachedMesh }\n","import { Our3DObject, Our3DGroup, OurLight, OurCamera, OurAmbientLight } from './Our3DObject'\nimport { useState } from 'react'\n// import { Our3DObject } from './OurCachedMeshes'\nimport * as CachedObjects from './OurCachedMeshes'\n\nconst Scene = cast => {\n  // Just a group of objects\n  const objectsToDraw = Our3DGroup()\n  if (cast) {\n    cast.forEach(castMember => objectsToDraw.add(castMember))\n  }\n\n  let light = OurLight([1, 1, 1], [1, 1, 1]) // Default light\n  let camera = OurCamera([0, 0, -5], [0, 0, 0], [0.6, -0.5, 0.5, -0.5, 1, 10]) // Default camera\n  let ambientLight = OurAmbientLight([0, 0, 0])\n\n  const animations = []\n\n  // Recursion requires functions to be declared outside object\n  const add = object => {\n    if (object.type === Our3DObject || object.type === Our3DGroup || object.type === CachedObjects.OurCachedObject) {\n      objectsToDraw.add(object)\n    } else if (object.type === OurLight) {\n      light = object\n    } else if (object.type === OurCamera) {\n      camera = object\n    } else if (object.type === OurAmbientLight) {\n      ambientLight = object\n    }\n  }\n\n  const remove = object => {\n    if (object.type === Our3DObject || object.type === Our3DGroup || object.type === CachedObjects.OurCachedObject) {\n      objectsToDraw.remove(object)\n    } else if (object.type === OurCamera && object === light) {\n      light = OurLight([0, 0, 0], [0, 0, 0]) //easier to make a black light than a null object\n    } else if (object.type === OurCamera && object === camera) {\n      camera = OurCamera([0, 0, 0], [0, 0, 0], [0, 0, 0, 0, 0, 0]) // should show nothing without breaking the app\n    } else if (object.type === OurAmbientLight) {\n      ambientLight = OurAmbientLight([0, 0, 0])\n    }\n  }\n\n  return {\n    get objectsToDraw() {\n      return objectsToDraw.flatGroup\n    },\n    add,\n    remove,\n    transform: objectsToDraw.transform,\n    get light() {\n      return light\n    },\n    get camera() {\n      return camera\n    },\n    get animation() {\n      return animations\n    },\n    get ambientLight() {\n      return ambientLight\n    },\n    addAnimation: newAnimation => {\n      animations.push(newAnimation)\n    },\n    tick: timeElapsed => {\n      animations.forEach(anim => {\n        if (anim.tick) {\n          anim.tick(timeElapsed)\n        }\n      })\n    },\n    click: event => {\n      animations.forEach(anim => {\n        if (anim.click) {\n          anim.click(event)\n        }\n      })\n    }\n  }\n}\n\nconst BigBang = cast => {\n  // React wrapper for Scene (using state)\n\n  const [universe, setUniverse] = useState({ scene: Scene(cast) })\n\n  const addToUniverse = object => {\n    universe.scene.add(object)\n  }\n  const removeFromUniverse = object => {\n    universe.scene.remove(object)\n  }\n\n  const addAnimation = anim => {\n    universe.scene.addAnimation(anim)\n  }\n\n  universe.tick = universe.scene.tick\n  universe.click = universe.scene.click\n\n  return {\n    universe,\n    setUniverse,\n    addToUniverse,\n    removeFromUniverse,\n    addAnimation\n  }\n}\n\nexport { BigBang, Scene }\n","import { MatrixLibrary } from './OurMatrix'\n\nconst MatrixAnimation = (objectToAffect, animationMatrix) => {\n  return {\n    tick: () => {\n      objectToAffect.transform(animationMatrix);\n    }\n  }\n}\n\nconst RotateAboutPoint = (objectToAffect, point = [0, 0, 0], rotation = [0, 0, 0]) => {\n  // Creates a rotation about point\n  /*\n  Algorithm from https://www.javatpoint.com/computer-graphics-rotation\n  1. Translate by point ('set' point as origin)\n  2. rotate by 'rotation'\n  3. Inverse of before rotation\n  */\n\n  const affectMatrix = MatrixLibrary.rotateAboutPoint(point, rotation)\n\n  return {\n    tick: () => {\n      objectToAffect.transform(affectMatrix)\n    }\n  }\n\n}\n\nexport { MatrixAnimation, RotateAboutPoint }","import { Geometries, OurMesh, Our3DGroup, Our3DObject, MatrixLibrary } from '../VIBAH/VIBAH'\n\nconst SphinxFactory = () => {\n  // Define our body parts\n  const body = Our3DObject(OurMesh(Geometries.Cylinder(0.5, 2, 8, 8), false), [1.1, 1, 0.1], 'body')\n\n  const EyeFactory = () => {\n    const socket = Our3DObject(OurMesh(Geometries.Sphere(1, 2, 8, 8), false), [0, 0, 0])\n    const sclera = Our3DObject(OurMesh(Geometries.Sphere(1, 2, 8, 8), false), [10, 10, 10])\n    const iris = Our3DObject(OurMesh(Geometries.Sphere(1, 2, 8, 8), false), [0.3, 0.8, 0.8])\n    socket.transform(MatrixLibrary.scaleMatrix(1.5, 1, 1))\n    sclera.transform(MatrixLibrary.scaleMatrix(1, 0.7, 0.7))\n    sclera.transform(MatrixLibrary.translationMatrix(-0.1, 0, 0))\n    iris.transform(MatrixLibrary.scaleMatrix(0.8, 0.5, 0.5))\n    iris.transform(MatrixLibrary.translationMatrix(-0.2, 0, 0))\n    const eye = Our3DGroup([socket, sclera, iris])\n    eye.transform(MatrixLibrary.rotationMatrix(0, Math.PI / 2, 0))\n    eye.transform(MatrixLibrary.scaleMatrix(0.14, 0.07, 0.14))\n    return eye\n  }\n\n  const face = Our3DObject(OurMesh(Geometries.Sphere(0.5, 5), false), [1.1, 1, 0.1])\n  const mouth = Our3DObject(OurMesh(Geometries.Sphere(0.1, 5), false), [0.3, 0.3, 0])\n  mouth.scale(1, 0.5, 0.5)\n\n  const lefteye = EyeFactory()\n  const righteye = EyeFactory()\n  const eyes = Our3DGroup([lefteye, righteye], 'eyes')\n  const head = Our3DGroup([face, mouth, eyes], 'head')\n\n  const ToeFactory = () => {\n    const toe1 = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 2, 8, 8), false), [1.1, 1, 0.1])\n    const toe2 = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 2, 8, 8), false), [1.1, 1, 0.1])\n    const toe3 = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 2, 8, 8), false), [1.1, 1, 0.1])\n    toe1.transform(MatrixLibrary.translationMatrix(0.35, 0, 0))\n    toe3.transform(MatrixLibrary.translationMatrix(-0.35, 0, 0))\n    return Our3DGroup([toe1, toe2, toe3])\n  }\n\n  const leftToes = ToeFactory()\n  const rightToes = ToeFactory()\n  leftToes.transform(MatrixLibrary.scaleMatrix(0.3, 1, 0.3))\n  rightToes.transform(MatrixLibrary.scaleMatrix(0.3, 1, 0.3))\n  const toes = Our3DGroup([leftToes, rightToes])\n\n  const leg1 = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 3, 8, 8), false), [1.1, 1, 0.1])\n  const leg2 = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 3, 8, 8), false), [1.1, 1, 0.1])\n  const legs = Our3DGroup([leg1, leg2])\n\n  // Orientate everything\n  legs.rotate(0, Math.PI / 4, 0)\n  head.rotate(0, Math.PI / 4, 0)\n  body.rotate(0, Math.PI / 4, 0)\n  leftToes.rotate(0, Math.PI / 4, 0)\n  rightToes.rotate(0, Math.PI / 4, 0)\n  lefteye.rotate(0, 0.3, 0)\n\n  // Put everything in position\n  leg1.translate(-4, -2, -1)\n  leg2.translate(-5, -2, -1)\n  lefteye.translate(0.42, 1.1, -0.78)\n  righteye.translate(0.2, 1.1, -0.55)\n  leftToes.translate(-2, -2, 1)\n  rightToes.translate(-3, -2, 1)\n  body.translate(-4.5, -1.5, -1)\n  head.translate(-3.2, -1, 0.3)\n  eyes.translate(-0.05, -1, 1.05)\n  mouth.translate(0.3, -0.1, 0.3)\n\n  const Sphinx = Our3DGroup([legs, body, head, toes])\n\n  Sphinx.scale(0.8, 0.8, 0.8)\n  Sphinx.translate(-2, -0.9, -1)\n\n  //Sphinx.rotate(0,-.5,0)\n  //Sphinx.translate(0,0,1)\n\n  return Sphinx\n}\n\nexport { SphinxFactory }\n","import { Geometries, OurMesh, Our3DGroup, Our3DObject, MatrixLibrary } from '../VIBAH/VIBAH'\n\nconst CamelFactory = (fidelity = 1) => {\n  // Define our body parts\n  const head = Our3DObject(OurMesh(Geometries.Sphere(0.5, 5 * fidelity), false), [0, 0, 0], \"head\")\n  const neck = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 1.5, 5 * fidelity, 10 * fidelity), false), [0, 0, 0], 'neck')\n  const body = Our3DObject(OurMesh(Geometries.Cylinder(1, 3.3, 5 * fidelity, 10 * fidelity), false), [0, 0, 0], 'body')\n\n  const legMesh = OurMesh(Geometries.Cylinder(0.25, 2, 5 * fidelity, 10 * fidelity), false)\n  const legFL = Our3DObject(legMesh, [0, 0, 0], 'legFL')\n  const legFR = Our3DObject(legMesh, [0, 0, 0], 'legFL')\n  const legBL = Our3DObject(legMesh, [0, 0, 0], 'legFL')\n  const legBR = Our3DObject(legMesh, [0, 0, 0], 'legFL')\n  const legs = Our3DGroup([legFL, legFR, legBL, legBR], 'legs')\n\n  const humpMesh = OurMesh(Geometries.Sphere(0.8, 5 * fidelity), false)\n  const hump1 = Our3DObject(humpMesh, [0, 0, 0], 'hump')\n  const hump2 = Our3DObject(humpMesh, [0, 0, 0], 'hump')\n  const humps = Our3DGroup([hump1, hump2], 'humps')\n\n  // Orientate everything\n  legs.transform(MatrixLibrary.rotationMatrix((3 * Math.PI) / 2, 0, 0))\n  neck.transform(MatrixLibrary.rotationMatrix((3 * Math.PI) / 2, 0, 0))\n  body.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, Math.PI / 2, 0))\n\n  // Put everything in position\n  head.transform(MatrixLibrary.translationMatrix(-1, 0.2, 0))\n  neck.transform(MatrixLibrary.translationMatrix(-1, -1.49, 0))\n  body.transform(MatrixLibrary.translationMatrix(-1.2, -2, 0))\n\n  legFL.transform(MatrixLibrary.translationMatrix(-0.9, -4, 0.5))\n  legFR.transform(MatrixLibrary.translationMatrix(-0.9, -4, -0.5))\n  legBL.transform(MatrixLibrary.translationMatrix(1.7, -4, 0.5))\n  legBR.transform(MatrixLibrary.translationMatrix(1.7, -4, -0.5))\n\n  hump1.transform(MatrixLibrary.translationMatrix(0, -1.3, 0))\n  hump2.transform(MatrixLibrary.translationMatrix(1.3, -1.3, 0))\n\n  // Apply a camel brown colour\n  const Camel = Our3DGroup(\n    [head, neck, body, legs, humps].map(shape => {\n      shape.setColors([193, 154, 107].map(rgb => rgb / 100))\n      return shape\n    })\n  )\n  return Camel\n}\n\nexport { CamelFactory }\n","// A collection of factories (hence detroit!)\n// group work (does not include our individual shapes)\n\nimport { Geometries, OurMesh, Our3DGroup, Our3DObject, MatrixLibrary } from '../VIBAH/VIBAH'\n\n// Placed into factories to make ExampleUniverse easier to read\n//  moderate loss of load efficiency is worth readability!!\nconst StarFactory = () => {\n  const star = Our3DObject(\n    OurMesh(\n      Geometries.Extrude(\n        [\n          [0, 1],\n          [0.25, 0.3],\n          [1, 0.3],\n          [0.4, -0.1],\n          [0.6, -0.8],\n          [0, -0.35],\n          [-0.6, -0.8],\n          [-0.4, -0.1],\n          [-1, 0.3],\n          [-0.25, 0.3]\n        ],\n        [\n          [0, 9, 1],\n          [2, 1, 3],\n          [4, 3, 5],\n          [6, 5, 7],\n          [8, 7, 9],\n          [1, 9, 5],\n          [3, 1, 5],\n          [7, 5, 9]\n        ]\n      ),\n      false\n    ),\n    [0, 1.5, 1]\n  )\n  star.transform(MatrixLibrary.scaleMatrix(0.7, 0.7, 0.7))\n  star.transform(MatrixLibrary.rotationMatrix(0.5, 0.5, 0.5))\n  star.transform(MatrixLibrary.translationMatrix(0.8, 0.4, 1.9))\n\n  const star2 = Our3DObject(\n    OurMesh(\n      Geometries.Extrude(\n        [\n          [0, 1],\n          [0.25, 0.3],\n          [1, 0.3],\n          [0.4, -0.1],\n          [0.6, -0.8],\n          [0, -0.35],\n          [-0.6, -0.8],\n          [-0.4, -0.1],\n          [-1, 0.3],\n          [-0.25, 0.3]\n        ],\n        [\n          [0, 9, 1],\n          [2, 1, 3],\n          [4, 3, 5],\n          [6, 5, 7],\n          [8, 7, 9],\n          [1, 9, 5],\n          [3, 1, 5],\n          [7, 5, 9]\n        ]\n      ),\n      false\n    ),\n    [1, 0, 0]\n  )\n  star2.transform(MatrixLibrary.scaleMatrix(0.7, 0.7, 0.7))\n  star2.transform(MatrixLibrary.rotationMatrix(0.5, 0.5, 0.5))\n  star2.transform(MatrixLibrary.translationMatrix(0.79, 0.4, 1.9))\n\n  const stars = Our3DGroup()\n  stars.add(star)\n  stars.add(star2)\n\n  return stars\n}\n\nconst IceCreamFactory = () => {\n  const sphere = Our3DObject(OurMesh(Geometries.Sphere(0.3, 5), false), [0, 0, 0])\n  sphere.setRandomColors(10)\n  sphere.transform(MatrixLibrary.scaleMatrix(2, 2, 2))\n  sphere.transform(MatrixLibrary.rotationMatrix(0, 0, 0.5))\n  sphere.transform(MatrixLibrary.translationMatrix(3, -0.2, 0.5))\n\n  const cone = Our3DObject(OurMesh(Geometries.Cone(0.5, 1, 8, 8), false), [0.7, 0, 0.8])\n  cone.setRandomColors(5, false)\n  cone.transform(MatrixLibrary.rotationMatrix(0, -0.3, 3.14))\n  cone.transform(MatrixLibrary.translationMatrix(3, -1, 0.5))\n\n  const IceCream = Our3DGroup()\n  IceCream.add(cone)\n  IceCream.add(sphere)\n\n  return IceCream\n}\n\nconst PyramidFactory = position => {\n  let pyramid = Our3DObject(OurMesh(Geometries.Cone(2.5, 3, 4, 4), false), [1, 1, 0.1])\n  pyramid.transform(MatrixLibrary.translationMatrix(...position))\n  return pyramid\n}\n\n\nexport { PyramidFactory, StarFactory, IceCreamFactory }","import { Geometries, OurMesh, Our3DGroup, Our3DObject, MatrixLibrary } from '../VIBAH/VIBAH'\n\nconst Vineyard = () => {\n  const GrapeFactory = () => {\n    // Colors\n    const grapeColor = [0.63, 0.13, 0.94]\n    const stemColor = [0, 1, 0]\n\n    // Stem\n    const stem = Our3DObject(OurMesh(Geometries.Cylinder(0.25, 1.5, 6), false), [...stemColor])\n    stem.translate(-1.5, 0, -1.5)\n    stem.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, 0, 0))\n    stem.scale(0.3, 0.3, 0.3)\n\n    // Top row of grapes\n    const toprow_grape1 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n\n    const toprow_grape2 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    toprow_grape2.translate(-0.3, 0, 0)\n\n    const toprow_grape3 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    toprow_grape3.translate(-0.6, 0, 0)\n\n    const toprow_grape4 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    toprow_grape4.translate(-0.9, 0, 0)\n\n    // Second row of grapes\n    const secondrow_grape1 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    secondrow_grape1.translate(-0.15, -0.3, 0)\n\n    const secondrow_grape2 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    secondrow_grape2.translate(-0.45, -0.3, 0)\n\n    const secondrow_grape3 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    secondrow_grape3.translate(-0.75, -0.3, 0)\n\n    // Third row of grapes\n    const thirdrow_grape1 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    thirdrow_grape1.translate(-0.3, -0.6, 0)\n\n    const thirdrow_grape2 = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    thirdrow_grape2.translate(-0.6, -0.6, 0)\n\n    // Final grape\n    const final_grape = Our3DObject(OurMesh(Geometries.Sphere(0.25, 6), false), [...grapeColor])\n    final_grape.translate(-0.45, -0.9, 0)\n\n    const GrapeFactory = Our3DGroup([\n      stem,\n      toprow_grape1,\n      toprow_grape2,\n      toprow_grape3,\n      toprow_grape4,\n      secondrow_grape1,\n      secondrow_grape2,\n      secondrow_grape3,\n      thirdrow_grape1,\n      thirdrow_grape2,\n      final_grape\n    ])\n\n    GrapeFactory.transform(MatrixLibrary.scaleMatrix(0.5, 0.5, 0.5))\n    GrapeFactory.scale(1, 1, 1)\n    return GrapeFactory\n  }\n\n  const first_grape_in_bunch = GrapeFactory().translate(0, 0.75, -1)\n  const second_grape_in_bunch = GrapeFactory().translate(-1, -0.25, -1)\n  const third_grape_in_bunch = GrapeFactory().translate(1, -0.25, -1)\n\n  const first_grape_position = [0, 0.75, -1]\n  const second_grape_position = [-1, -0.25, -1]\n  const third_grape_position = [1, -0.25, -1]\n\n  const first_grape_tracking_position = [-1.75, 0, -1]\n  const second_grape_tracking_position = [-2.5, -1, -1]\n  const third_grape_tracking_position = [-1, -1, -1]\n\n  const Bunch = Our3DGroup([first_grape_in_bunch, second_grape_in_bunch, third_grape_in_bunch])\n  return {\n    Bunch,\n    first_grape_position,\n    second_grape_position,\n    third_grape_position,\n    first_grape_tracking_position,\n    second_grape_tracking_position,\n    third_grape_tracking_position,\n    first_grape_in_bunch,\n    second_grape_in_bunch,\n    third_grape_in_bunch\n  }\n}\n\nexport { Vineyard }\n","// Import our cast\nimport { SphinxFactory } from '../objects/sphinx'\nimport { CamelFactory } from '../objects/camel'\nimport { StarFactory, PyramidFactory } from '../objects/Detroit'\nimport { ShepherdFactory } from '../objects/shepherd'\nimport { UFOFactory } from '../objects/UFO'\nimport { MummyFactory } from '../objects/mummy'\nimport { Vineyard } from '../objects/vineyard'\n\n// Import our library\nimport {\n  Geometries,\n  ReactWebGL,\n  BigBang,\n  OurMesh,\n  Our3DGroup,\n  Our3DObject,\n  OurLight,\n  OurCamera,\n  OurAmbientLight,\n  MatrixLibrary,\n  Animations\n} from '../VIBAH/VIBAH'\n\n// Alternatively can import as\n// import * as VIBAH from './VIBAH/VIBAH\n\nconst ExampleUniverse = () => {\n  let universe = BigBang()\n\n  // Pyramids\n  const pyramid = PyramidFactory([-0.2, -1, -3])\n  const pyramid2 = PyramidFactory([-4, -1, -4])\n  const pyramid3 = PyramidFactory([4, -1, -4])\n  universe.addToUniverse(pyramid)\n  universe.addToUniverse(pyramid2)\n  universe.addToUniverse(pyramid3)\n\n  universe.addAnimation({\n    movingUp: true,\n    displacement: 0,\n    tick: function (progress) {\n      if (this.isActive) {\n        if (this.movingUp) {\n          pyramid3.translate(0, 0.01, 0)\n          this.displacement++\n          if (this.displacement === 100) {\n            this.movingUp = false\n          }\n        } else {\n          pyramid3.translate(0, -0.01, 0)\n          this.displacement--\n          if (this.displacement === 0) {\n            this.movingUp = true\n          }\n        }\n      }\n    },\n    click: function () {\n      this.isActive = !this.isActive\n    }\n  })\n\n  // Amazing background :)\n\n  let ground = Our3DObject(OurMesh(Geometries.RegularPolygon(4), false), [0.5, 0.4, 0.2])\n  ground.transform(MatrixLibrary.scaleMatrix(15, 15, 1))\n  ground.transform(MatrixLibrary.rotationMatrix(-Math.PI / 2, 0, Math.PI / 4))\n  ground.transform(MatrixLibrary.translationMatrix(0, -2.5, 0))\n  universe.addToUniverse(ground)\n\n  let sky = Our3DObject(OurMesh(Geometries.RegularPolygon(4), false), [2.5, 5, 20.5])\n  sky.transform(MatrixLibrary.scaleMatrix(15, 15, 1))\n  sky.transform(MatrixLibrary.rotationMatrix(0, 0, Math.PI / 4))\n  sky.transform(MatrixLibrary.translationMatrix(0, 0, -3))\n  universe.addToUniverse(sky)\n\n  // From our cast\n  let sphinx = SphinxFactory()\n  universe.addToUniverse(sphinx)\n\n  universe.addAnimation({\n    displacement: 0,\n    movingLeft: false,\n    tick: function (progress) {\n      if (!this.movingLeft) {\n        sphinx.getObjectByName('head').getObjectByName('eyes').translate(0.001, 0, 0)\n        this.displacement++\n        if (this.displacement === 100) {\n          this.displacement = 0\n          this.movingLeft = true\n        }\n      } else {\n        sphinx.getObjectByName('head').getObjectByName('eyes').translate(-0.001, 0, 0)\n        this.displacement++\n        if (this.displacement === 100) {\n          this.displacement = 0\n          this.movingLeft = false\n        }\n      }\n    }\n  })\n\n  const mummy = MummyFactory()\n  universe.addToUniverse(mummy)\n\n  const camel1 = CamelFactory().scale(0.25, 0.25, 0.25).transform(MatrixLibrary.translationMatrix(1, -1.5, -1))\n  const camel2 = CamelFactory()\n    .scale(0.25, 0.25, 0.25)\n    .translate(-1, -1.5, -1)\n    .rotateAboutPoint([-1, -1.5, -1], [0, Math.PI, 0])\n    .setWireframe(true)\n    .setColors([0,100,0])\n  const camelHerd = Our3DGroup().add(camel1).add(camel2)\n  universe.addToUniverse(camelHerd)\n\n  const shepherd = ShepherdFactory()\n  universe.addToUniverse(shepherd)\n  let starrySky = Our3DGroup()\n\n  for (let i = 0; i < 8; i++) {\n    starrySky.add(\n      StarFactory()\n        .scale(0.25, 0.25, 0.25)\n        .translate(Math.random() * 6 - 3, Math.random() * 2 - 1, Math.random() * 2 - 1)\n    )\n  }\n  universe.addToUniverse(starrySky)\n\n  const UFO = UFOFactory().translate(3, 0, -1)\n  universe.addToUniverse(UFO)\n  universe.addAnimation(\n    Animations.RotateAboutPoint(UFO.getObjectByName('beam').getObjectByName('outer'), [3, 0, -1], [0, 0.01, 0])\n  )\n  universe.addAnimation(\n    Animations.RotateAboutPoint(UFO.getObjectByName('beam').getObjectByName('inner'), [3, 0, -1], [0, -0.01, 0])\n  )\n  universe.addAnimation(Animations.RotateAboutPoint(UFO, [3, 0, -1], [0, -0.001, 0]))\n\n  universe.addAnimation({\n    displacement: 0,\n    movingUp: false,\n    tick: function (progress) {\n      if (!this.movingUp) {\n        UFO.translate(0, -0.001, 0)\n        this.displacement++\n        if (this.displacement === 100) {\n          this.displacement = 0\n          this.movingUp = true\n        }\n      } else {\n        UFO.translate(0, 0.001, 0)\n        this.displacement++\n        if (this.displacement === 100) {\n          this.displacement = 0\n          this.movingUp = false\n        }\n      }\n    }\n  })\n\n  const bunchOfGrapes = Vineyard()\n  universe.addToUniverse(bunchOfGrapes.Bunch)\n\n  // We have to see something!\n  const camera = OurCamera([0, 1, -5], [0, 0, 0], [0.5, -0.5, 1, -1, 1, 10])\n  // const camera = OurCamera([0, 1, -5], [0, 0, 0], [1, -1, 1, -1, 2, -2], MatrixLibrary.orthographicProjectionMatrix)\n\n  universe.addToUniverse(camera)\n\n  const light = OurLight([-2, 0, 10], [5, 5, 5])\n  universe.addToUniverse(light)\n\n  const AmbientLight = OurAmbientLight([3, 3, 3])\n  universe.addToUniverse(AmbientLight)\n\n  const unleashCurse = {\n    curseUnleahsed: false,\n    brighten: false,\n    displacement: 0,\n    toggleCurse: function () {\n      this.curseUnleahsed = !this.curseUnleahsed\n    },\n    tick: function () {\n      if (this.curseUnleahsed) {\n        if (this.displacement < 100) {\n          sphinx.translate(0.05, 0.008, 0.05)\n          sphinx.rotate(0, -0.006, 0)\n          //sphinx.scale(1.01,1.01,1.01)\n          this.displacement++\n        } else if (this.displacement < 150) {\n          if (this.brighten) {\n            AmbientLight.newLight = [10, 10, 10]\n          } else {\n            AmbientLight.newLight = [0.1, 0.1, 0.1]\n          }\n          this.brighten = !this.brighten\n          this.displacement++\n        } else if (this.displacement < 151) {\n          universe.removeFromUniverse(sphinx)\n          this.displacement++\n        } else if (this.displacement < 200) {\n          if (this.brighten) {\n            AmbientLight.newLight = [10, 10, 10]\n          } else {\n            AmbientLight.newLight = [0.1, 0.1, 0.1]\n          }\n          this.brighten = !this.brighten\n          pyramid.toggleWireframe()\n          this.displacement++\n        } else if (this.displacement < 350) {\n          if (this.brighten) {\n            AmbientLight.newLight = [10, 10, 10]\n          } else {\n            AmbientLight.newLight = [0.1, 0.1, 0.1]\n          }\n          this.brighten = !this.brighten\n          pyramid.toggleWireframe()\n          mummy.getObjectByName('mummy').rotate(0.001, 0, 0)\n          this.displacement++\n        } else if (this.displacement < 351) {\n          AmbientLight.newLight = [3, 3, 3]\n          pyramid.toggleWireframe()\n\n          sphinx = SphinxFactory()\n          universe.addToUniverse(sphinx)\n          sphinx.getObjectByName('eyes').translate(0.2, 0, 0.1)\n\n          this.displacement++\n        }\n      }\n    }\n  }\n  universe.addAnimation(unleashCurse)\n\n  const earthquake = {\n    timeElapsed: 3000,\n    toggleEarthquake: function () {\n      this.timeElapsed = 0\n    },\n    tick: function (progress) {\n      if (this.timeElapsed < 3000) {\n        this.timeElapsed = this.timeElapsed + progress\n        universe.universe.scene.objectsToDraw.forEach(object =>\n          object.translate(Math.random() * 0.01 - 0.005, Math.random() * 0.01 - 0.005, Math.random() * 0.01 - 0.005)\n        )\n      }\n    }\n  }\n\n  universe.addAnimation(earthquake)\n\n  const dancingGrapes = {\n    dancing: false,\n    rave: false,\n    ferrisWheel: false,\n    toggleDancing: function () {\n      this.dancing = !this.dancing\n    },\n    toggleRave: function () {\n      this.rave = !this.rave\n    },\n    toggleferrisWheel: function () {\n      this.ferrisWheel = !this.ferrisWheel\n    },\n    tick: function () {\n      if (this.dancing) {\n        bunchOfGrapes.first_grape_in_bunch.rotateAboutPoint(\n          [...bunchOfGrapes.first_grape_tracking_position],\n          [0, -0.05, 0]\n        )\n        bunchOfGrapes.second_grape_in_bunch.rotateAboutPoint(\n          [...bunchOfGrapes.second_grape_tracking_position],\n          [0, -0.05, 0]\n        )\n        bunchOfGrapes.third_grape_in_bunch.rotateAboutPoint(\n          [...bunchOfGrapes.third_grape_tracking_position],\n          [0, -0.05, 0]\n        )\n      }\n      if (this.rave) {\n        bunchOfGrapes.first_grape_in_bunch.rotateAboutPoint(\n          [...bunchOfGrapes.first_grape_position],\n          [Math.random() * 0.025, Math.random() * 0.25, Math.random() * 0.025]\n        )\n        bunchOfGrapes.second_grape_in_bunch.rotateAboutPoint(\n          [...bunchOfGrapes.second_grape_position],\n          [Math.random() * -0.25, Math.random() * 0.025, Math.random() * -0.025]\n        )\n        bunchOfGrapes.third_grape_in_bunch.rotateAboutPoint(\n          [...bunchOfGrapes.third_grape_position],\n          [Math.random() * 0.25, Math.random() * -0.25, Math.random() * 0.025]\n        )\n      }\n      if (this.ferrisWheel) {\n        const point = [Math.random() * 0.5, Math.random() * 0.5, Math.random() * -1]\n        const rotation = [0, 0, Math.random() * 0.5]\n        bunchOfGrapes.Bunch.group.forEach(grape => grape.rotateAboutPoint([...point], [...rotation]))\n      }\n    }\n  }\n\n  universe.addAnimation(dancingGrapes)\n\n  const shepherdAbilities = {\n    center: [-0.2, -2, 1],\n    angle: Math.PI / 2,\n    toggleFlying: function () {\n      this.flying = !this.flying\n    },\n    toggleLeft: function () {\n      this.flying = true\n      this.rightTurn = false\n      this.leftTurn = !this.leftTurn\n    },\n    toggleRight: function () {\n      this.flying = true\n      this.rightTurn = !this.rightTurn\n      this.leftTurn = false\n    },\n    tick: function (progress) {\n      if (this.flying) {\n        shepherd.translate(Math.cos(this.angle) * 0.02, Math.sin(this.angle) * 0.02, 0)\n        this.center[0] += Math.cos(this.angle) * 0.02\n        this.center[1] += Math.sin(this.angle) * 0.02\n      }\n      if (this.leftTurn) {\n        this.angle -= 0.075\n        shepherd.rotateAboutPoint([this.center[0], this.center[1], this.center[2]], [0, 0, -0.075])\n      }\n      if (this.rightTurn) {\n        shepherd.rotateAboutPoint([this.center[0], this.center[1], this.center[2]], [0, 0, 0.075])\n        this.angle += 0.075\n      }\n    }\n  }\n\n  universe.addAnimation(shepherdAbilities)\n\n  const camelInternalAnimation = {\n    // Internal movement\n    camelHeadBob: false,\n    timeElapsed: 0,\n    objectsToAffect: [camel1.getObjectByName('head'), camel1.getObjectByName('neck')],\n    tick: function (progress) {\n      if (this.camelHeadBob) {\n        this.timeElapsed = this.timeElapsed > 1000 ? (this.timeElapsed = 0) : this.timeElapsed + progress\n        if (this.timeElapsed < 500) {\n          this.objectsToAffect.forEach(object => {\n            object.rotateAboutPoint([1, -1.5, -1], [0, 0, 0.01])\n          })\n        } else {\n          this.objectsToAffect.forEach(object => {\n            object.rotateAboutPoint([1, -1.5, -1], [0, 0, -0.01])\n          })\n        }\n      }\n    },\n    toggleAnimation: function () {\n      this.camelHeadBob = !this.camelHeadBob\n    }\n  }\n  universe.addAnimation(camelInternalAnimation)\n\n  const moveCamera = {\n    // Demonstrate \"Ability to change camera position and viewpoint\"\n    moving: false,\n    toggleMoving: function () {\n      this.moving = !this.moving\n    },\n    tick: function () {\n      if (this.moving) {\n        camera.rotate(0, 0.01, 0.001)\n      }\n    }\n  }\n  universe.addAnimation(moveCamera)\n\n  universe.addAnimation({\n    // Demonstrate \"Ability to add and remove objects to/from the scene\"\n    timeElapsed: 0,\n    camelInScene: true,\n    timeBetween: 3000,\n    tick: function (progress) {\n      this.timeElapsed = this.timeElapsed > this.timeBetween ? (this.timeElapsed = 0) : this.timeElapsed + progress\n      if (this.timeElapsed > this.timeBetween) {\n        this.timeElapsed = 0\n        if (this.camelInScene) {\n          universe.removeFromUniverse(camel2)\n          this.camelInScene = false\n        } else {\n          universe.addToUniverse(camel2)\n          this.camelInScene = true\n        }\n      }\n    }\n  })\n\n  const changeView = {\n    isPerspective: true,\n    toggleView: function () {\n      if (!this.isPerspective) {\n        const perspectiveCamera = OurCamera([0, 1, -5], [0, 0, 0], [0.5, -0.5, 1, -1, 1, 10])\n        universe.addToUniverse(perspectiveCamera)\n        this.isPerspective = !this.isPerspective\n      } else {\n        const orthographicCamera = OurCamera(\n          [0, 1, -5],\n          [0, 0, 0],\n          [2.5, -2.5, 5, -5, -5, 10],\n          MatrixLibrary.orthographicProjectionMatrix\n        )\n        universe.addToUniverse(orthographicCamera)\n        this.isPerspective = !this.isPerspective\n      }\n    }\n  }\n\n  universe.addAnimation({\n    timeElapsed: 0,\n    timeBetween: 3000,\n\n    // Demonstrate \"Ability to compute lighting in both faceted/flat and smooth styles\"\n    tick: function (progress) {\n      if (this.timeElapsed > this.timeBetween) {\n        this.timeElapsed = 0\n        pyramid.toggleFaceted()\n      } else {\n        this.timeElapsed += progress\n      }\n    }\n  })\n\n  const facetedAnimation = {\n    change: false,\n    tick: function(){\n      if(this.change){\n        this.change = false\n        universe.universe.scene.objectsToDraw.forEach(sceneObject => sceneObject.toggleFaceted())\n      }\n    },\n    sceneToggleFaceted: function(){\n      this.change = true\n    }\n  }\n  universe.addAnimation(facetedAnimation)\n\n  // put the things we want to connect directly to react\n  const thingsWeWant = {\n    addAnimation: universe.addAnimation,\n    toggleUnleshCurse: () => {\n      unleashCurse.toggleCurse()\n    },\n    toggleCamelAnimation: () => {\n      camelInternalAnimation.toggleAnimation()\n    },\n    toggleDancing: () => {\n      dancingGrapes.toggleDancing()\n    },\n    toggleRave: () => {\n      dancingGrapes.toggleRave()\n    },\n    toggleferrisWheel: () => {\n      dancingGrapes.toggleferrisWheel()\n    },\n    toggleEarthquake: () => {\n      earthquake.toggleEarthquake()\n    },\n    toggleFlying: () => {\n      shepherdAbilities.toggleFlying()\n    },\n    toggleRight: () => {\n      shepherdAbilities.toggleLeft()\n    },\n    toggleLeft: () => {\n      shepherdAbilities.toggleRight()\n    },\n    makeWireframe: () => {\n      // Demonstrate \"Ability to toggle between wireframe and solid rendering\"\n      universe.universe.scene.objectsToDraw.forEach(object => object.toggleWireframe())\n    },\n    toggleMoveCamera: () => {\n      moveCamera.toggleMoving()\n    },\n    changeCamera: () => {\n      changeView.toggleView()\n    },\n    sceneToggleFaceted: () => {\n      facetedAnimation.sceneToggleFaceted()\n    }\n  }\n  return { universe, thingsWeWant }\n}\n\nconst ExampleWebGL = props => {\n  const { universe, thingsWeWant } = ExampleUniverse()\n\n  return (\n    <article>\n      <ReactWebGL universe={universe.universe} />\n      <section>\n        <button onClick={thingsWeWant.makeWireframe}>Toggle wireframe</button>\n        <button onClick={thingsWeWant.sceneToggleFaceted}>Toggle Faceted/Smooth</button>\n        <button onClick={thingsWeWant.toggleMoveCamera}>Toggle camera move</button>\n        <button onClick={thingsWeWant.changeCamera}>Toggle camera</button>\n        <button onClick={thingsWeWant.toggleEarthquake}>You make my earth quake</button>\n        <button onClick={thingsWeWant.toggleUnleshCurse}>Unleash Ancient Curse</button>\n        <button onClick={thingsWeWant.toggleCamelAnimation}>Straight vibing</button>\n        <br />\n        <button onClick={thingsWeWant.toggleDancing}> Dancing    </button>\n        <button onClick={thingsWeWant.toggleRave}> Rave   </button>\n        <button onClick={thingsWeWant.toggleferrisWheel}>   Ferris Wheel  </button>\n        <br />\n        <button onClick={thingsWeWant.toggleLeft}></button>\n        <button onClick={thingsWeWant.toggleFlying}>Fly!</button>\n        <button onClick={thingsWeWant.toggleRight}></button>\n      </section>\n    </article>\n  )\n}\n\nexport { ExampleWebGL }\n","import { Geometries, OurMesh, Our3DGroup, Our3DObject } from '../VIBAH/VIBAH'\n\nconst MummyFactory = () => {\n  const mummyColor = [3, 3, 3]\n\n  // Define our body parts\n  const upperBody = Our3DObject(OurMesh(Geometries.Cylinder(0.5, 1, 8, 8), false), mummyColor, 'upper body')\n  const lowerBody = Our3DObject(OurMesh(Geometries.Cone(0.5, 2, 8, 8), false), mummyColor, 'upper body')\n  const feet = Our3DObject(OurMesh(Geometries.Cylinder(0.3, 0.5, 8, 8), false), mummyColor, 'feet')\n  const body = Our3DGroup([upperBody, lowerBody, feet], 'body')\n\n  const face = Our3DObject(OurMesh(Geometries.Sphere(0.4, 6)), mummyColor, 'face')\n  const head = Our3DGroup([face], 'head')\n\n  const mummy = Our3DGroup([body, face], 'mummy')\n\n  const sarcophagus = Our3DObject(\n    OurMesh(\n      Geometries.Extrude(\n        [\n          [0.5, 0],\n          [-0.5, 0],\n          [-1, 3],\n          [0, 4],\n          [1, 3]\n        ],\n        [\n          [0, 1, 4],\n          [1, 2, 4],\n          [4, 2, 3]\n        ]\n      ),\n      false\n    ),\n    [0.8, 0.5, 0.3]\n  )\n\n  // Orientate everything\n  upperBody.rotate(Math.PI / 2, 0, 0)\n  lowerBody.rotate(Math.PI, 0, 0)\n\n  // Put everything in position\n  head.translate(0, 0.4, 0)\n  lowerBody.translate(0, -2, 0)\n  feet.translate(0, -5.5, -0.5)\n  sarcophagus.translate(0, -3, -0.5)\n\n  // Rescale everything\n  feet.scale(10, 5, 10)\n\n  // Create mummy\n  const Mummy = Our3DGroup([mummy, sarcophagus])\n\n  // Reorient group\n  Mummy.scale(0.4, 0.4, 0.4)\n  Mummy.rotate(-Math.PI / 6, 0, 0)\n  Mummy.translate(0, -1, -2.5)\n\n  return Mummy\n}\n\nexport { MummyFactory }\n","import { Geometries, OurMesh, Our3DGroup, Our3DObject, MatrixLibrary } from '../VIBAH/VIBAH'\n\nconst ShepherdFactory = () => {\n  const head = Our3DObject(OurMesh(Geometries.Sphere(0.4, 9), false), [1, 1, 0])\n  head.transform(MatrixLibrary.translationMatrix(1, 1, 1))\n\n  const body = Our3DObject(OurMesh(Geometries.Cone(0.5, 2, 12, 4), false), [1, 1, 1])\n  body.transform(MatrixLibrary.translationMatrix(1, -0.1, 1))\n\n  let leftLeg = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 1.5, 8, 6), false), [1, 1, 0.1])\n  leftLeg.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, 0, 0))\n  leftLeg.transform(MatrixLibrary.translationMatrix(0.75, -1, 1))\n\n  let rightLeg = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 1.5, 8, 6), false), [1, 1, 0.1])\n  rightLeg.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, 0, 0))\n  rightLeg.transform(MatrixLibrary.translationMatrix(1.2, -1, 1))\n\n  let shirt = Our3DObject(\n    OurMesh(\n      Geometries.Lathe(\n        [\n          [0.3, 0],\n          [1, 2]\n        ],\n        8,\n        0,\n        Math.PI * 2\n      ),\n      false\n    ),\n    [1, 0, 0]\n  )\n  shirt.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, 0, 0))\n  shirt.transform(MatrixLibrary.translationMatrix(1, 0.5, 1))\n\n  let arm = Our3DObject(OurMesh(Geometries.Cylinder(0.2, 1.5, 8, 6), false), [1, 1, 0.1])\n  arm.transform(MatrixLibrary.translationMatrix(0.1, -0.1, 1.1))\n  arm.transform(MatrixLibrary.rotationMatrix(0, Math.PI / 2, 0))\n\n  let staff = Our3DGroup([], 'staff???')\n\n  let staffBase = Our3DObject(OurMesh(Geometries.Cylinder(0.1, 3.5, 8, 6), false), [1.21, 0.63, 0.13], 'staffBase')\n  staffBase.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, 0, 0))\n  staffBase.transform(MatrixLibrary.translationMatrix(2.2, 0.8, 0))\n\n  let hook1 = Our3DObject(OurMesh(Geometries.Cylinder(0.1, 1, 8, 6), false), [1.21, 0.63, 0.13])\n  hook1.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, Math.PI / 4, 0))\n  hook1.transform(MatrixLibrary.translationMatrix(2.5, 1, 0))\n\n  let hook2 = Our3DObject(OurMesh(Geometries.Cylinder(0.1, 0.5, 8, 6), false), [1.21, 0.63, 0.13])\n  hook2.transform(MatrixLibrary.rotationMatrix(Math.PI / 2, (3 * Math.PI) / 4, 0))\n  hook2.transform(MatrixLibrary.translationMatrix(2.255, 0.65, 0))\n\n  staff.add(staffBase)\n  staff.add(hook1)\n  staff.add(hook2)\n\n  let shepherd = Our3DGroup()\n  shepherd.add(head)\n  shepherd.add(body)\n  shepherd.add(leftLeg)\n  shepherd.add(rightLeg)\n  shepherd.add(shirt)\n  shepherd.add(arm)\n  shepherd.add(staff)\n\n  shepherd.transform(MatrixLibrary.scaleMatrix(0.2, 0.2, 0.2))\n  shepherd.transform(MatrixLibrary.translationMatrix(-0.5, -1.9, 0))\n\n  return shepherd\n}\n\nexport { ShepherdFactory }\n","import { Geometries, OurMesh, Our3DGroup, Our3DObject } from '../VIBAH/VIBAH'\n\nconst UFOFactory = () => {\n  // Define the main body of our ship\n  const ShipFactory = () => {\n    const saucer = Our3DObject(OurMesh(Geometries.Sphere(1.2, 8)), [0.5, 0.5, 0.5])\n    saucer.scale(1, 0.25, 1)\n    const cockpit = Our3DObject(OurMesh(Geometries.Sphere(0.5, 8), true), [0.5, 0.7, 1])\n    cockpit\n      .rotate(0, Math.PI / 2, 0)\n      .scale(1, 0.9, 1)\n      .translate(0, 0.35, 0)\n    const interior = Our3DObject(OurMesh(Geometries.RegularPolygon(16)), [0, 0, 0.05])\n    interior\n      .rotate(Math.PI / 2, 0, 0)\n      .scale(0.5, 0.5, 0.5)\n      .translate(0, 0.25, 0)\n\n    const ship = Our3DGroup([saucer, cockpit, interior])\n    return ship\n  }\n\n  const ship = ShipFactory()\n\n  const AlienFactory = () => {\n    const head = Our3DObject(OurMesh(Geometries.Sphere(0.1, 8)), [0, 0.8, 0.6])\n    head.scale(1, 1.2, 1).translate(0, 0.25, 0)\n\n    const body = Our3DObject(OurMesh(Geometries.Sphere(0.15, 8)), [0, 0.8, 0.6])\n    body.scale(1, 1.5, 1)\n\n    const armLeft = Our3DObject(OurMesh(Geometries.Cylinder(0.04, 0.3, 6)), [0, 0.8, 0.6], 'left')\n    armLeft.translate(0.11, 0.17, 0)\n    const armRight = Our3DObject(OurMesh(Geometries.Cylinder(0.04, 0.3, 6)), [0, 0.8, 0.6], 'right')\n    armRight.translate(-0.11, 0.17, 0)\n    const arms = Our3DGroup([armLeft, armRight], 'arms').rotate(0.5, 0, 0)\n\n    const eyeLeft = Our3DObject(OurMesh(Geometries.Sphere(0.06, 6)), [0, 0, 0], 'left')\n    eyeLeft.translate(0.015, 0.26, 0.04)\n    const eyeRight = Our3DObject(OurMesh(Geometries.Sphere(0.06, 6)), [0, 0, 0], 'right')\n    eyeRight.translate(-0.015, 0.26, 0.04)\n    const eyes = Our3DGroup([eyeLeft, eyeRight], 'eyes')\n\n    const alien = Our3DGroup([head, body, arms, eyes])\n    return alien\n  }\n\n  const alien = AlienFactory()\n  alien.translate(0, 0.25, 0)\n\n  const BeamFactory = () => {\n    const outer = Our3DObject(OurMesh(Geometries.Cone(0.5, 2, 6), true), [0, 0.8, 0.8], 'outer')\n    const inner = Our3DObject(OurMesh(Geometries.Cone(0.4, 2, 6), true), [0.8, 0.0, 0.8], 'inner')\n\n    const beam = Our3DGroup([outer, inner], 'beam')\n    return beam\n  }\n\n  const beam = BeamFactory()\n  beam.translate(0, -0.5, 0)\n\n  const UFO = Our3DGroup([ship, alien, beam])\n\n  return UFO\n}\n\nexport { UFOFactory }\n","// Import our library\nimport { ReactWebGL, BigBang, OurAmbientLight, OurCamera, Animations } from '../VIBAH/VIBAH'\n// import * as VIBAH from '../VIBAH/VIBAH'\n// import * as CachedObjects from '../VIBAH/OurCachedMeshes'\nimport { Our3DObject, OurMesh } from '../VIBAH/Our3DObject'\nimport { Cylinder } from '../VIBAH/OurGeometryLibrary'\nimport { IceCreamFactory } from '../objects/Detroit'\nimport { Vineyard } from '../objects/vineyard'\nimport { CamelFactory } from '../objects/camel'\n\nconst Sandbox = () => {\n  const universe = BigBang()\n\n  // Leg lol\n  let leftLeg = Our3DObject(OurMesh(Cylinder(0.2, 1.5, 8, 32), false), [1, 1, 0.1])\n  universe.addToUniverse(leftLeg)\n\n  // Yummy :)\n  const IceCream = IceCreamFactory()\n  universe.addToUniverse(IceCream) // Demonstrating animations can be added after addToUniverse call\n  universe.addAnimation(Animations.RotateAboutPoint(IceCream, [3, -1, 0.5], [0, 0, 0.1]))\n\n  // grapes\n  const grapes = Vineyard().Bunch.translate(0.5, -1, -0.2)\n  universe.addToUniverse(grapes)\n\n  // camel\n  const camel = CamelFactory().scale(0.5, 0.5, 0.5).translate(-2.5, 0, 0)\n  universe.addToUniverse(camel)\n\n  const cylinder = Our3DObject(OurMesh(Cylinder())).translate(-1, -1, -1)\n  universe.addToUniverse(cylinder)\n  // console.log('old cylinder', cylinder)\n\n  // Our cache testing - not effective (even 80 cache hits only reduces load time by 8s)\n  // const newcylinder = CachedObjects.OurCachedObject(CachedObjects.OurCachedMesh(Cylinder())).translate(1, 1, 1)\n  // universe.addToUniverse(newcylinder)\n  // console.log('new cylinder', newcylinder)\n\n\n  // const cylinder2 = CachedObjects.OurCachedObject(CachedObjects.OurCachedMesh(Cylinder())).translate(1, 1, 1)\n  // universe.addToUniverse(cylinder2)\n  // console.log('new cylinder 2', cylinder2)\n\n  // We have to see something!\n  const camera = OurCamera([0, 1, -5], [0, 0, 0], [0.5, -0.5, 1, -1, 1, 10])\n  universe.addToUniverse(camera)\n\n  const light = OurAmbientLight([1, 1, 1])\n  universe.addToUniverse(light)\n\n  return universe\n}\n\nconst OurSandbox = props => {\n  const { universe } = Sandbox()\n  return <ReactWebGL universe={universe} />\n}\n\nexport { OurSandbox }\n","/**\n * This React app serves as a very thin wrapper around what is otherwise pure WebGL code.\n * With the exception of a couple of reusable modules, the BareBonesWebGL and LessBareBonesWebGL\n * components are devoid of design---they are meant to introduce you to WebGL but are not meant\n * to be models to emulate. In other words, focus on the functionality and not the form. Once you\n * feel youve gotten into a groove with WebGL yourself, feel free to delete these components and\n * underlying modules so you can go with your own approach for a high-level 3D graphics library.\n */\nimport { BrowserRouter as Router, NavLink, Route, Switch } from 'react-router-dom'\n\nimport './App.css'\n\nimport { ExampleWebGL } from './scenes/OurScene'\nimport { OurSandbox } from './scenes/OurSandbox'\n// import BareBonesWebGL from './BareBonesWebGL'\n// import LessBareBonesWebGL from './LessBareBonesWebGL'\n\nconst Greeting = () => (\n  <article>\n    <h1>Choose which to look at above</h1>\n    <p>\n      `Our Scene` contains a fun Egyptian scene.\n      `Our Sandbox` has a bunch of random objects\n    </p>\n    <p>\n      <bold> WARNING: normals are computed on load so the load will take a very long time. Eventually, these will be cached (after the first load) but the initial load and some buttons may take a while </bold>\n    </p>\n  </article>\n)\n\nconst App = () => {\n  return (\n    <article className=\"App\">\n      <Router>\n        <nav>\n          {/* <NavLink activeClassName=\"current\" to=\"/bare-bones-webgl\">\n            Bare Bones WebGL\n          </NavLink>\n\n          <NavLink activeClassName=\"current\" to=\"/less-bare-bones-webgl\">\n            Less Bare Bones WebGL\n          </NavLink> */}\n\n          <NavLink activeClassName=\"current\" to=\"/our-webgl\">\n            Our Scene\n          </NavLink>\n          <NavLink activeClassName=\"current\" to=\"/our-sandbox\">\n            Our Sandbox\n          </NavLink>\n        </nav>\n\n        <main>\n          <Switch>\n            {/* <Route path=\"/bare-bones-webgl\" component={BareBonesWebGL} />\n            <Route path=\"/less-bare-bones-webgl\" component={LessBareBonesWebGL} /> */}\n            <Route path=\"/our-webgl\" component={ExampleWebGL} />\n            <Route path='/our-sandbox' component={OurSandbox} />\n            <Route component={Greeting} />\n          </Switch>\n        </main>\n      </Router>\n    </article>\n  )\n}\n\nexport default App\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n\nexport default reportWebVitals\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}